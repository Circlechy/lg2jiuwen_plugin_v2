# 迁移阶段具体方案

> 版本：V4
> 更新日期：2026-01-24

## 阶段一：项目检测 (ProjectDetectorComp)

### 输入
- `source_path`: 源文件或目录路径

### 处理逻辑
1. 判断是单文件还是多文件项目
2. 扫描项目结构，收集 Python 文件列表
3. 分析文件间的导入依赖关系
4. 确定依赖顺序（被依赖的文件先处理）

### 输出
- `file_list`: 文件列表
- `dependency_order`: 依赖顺序
- `is_multi_file`: 是否多文件项目
- `project_root`: 项目根目录

---

## 阶段二：文件加载 (FileLoaderComp)

### 输入
- `file_list`: 文件列表
- `dependency_order`: 依赖顺序

### 处理逻辑
1. 按依赖顺序读取文件内容
2. 处理文件编码

### 输出
- `file_contents`: 文件内容字典 `{file_path: content}`
- `dependency_order`: 依赖顺序

---

## 阶段三：AST 解析 (ASTParserComp)

### 输入
- `file_contents`: 文件内容字典
- `dependency_order`: 依赖顺序

### 处理逻辑
1. 使用 Python `ast` 模块解析每个文件
2. 构建 AST 映射表

### 输出
- `ast_map`: AST 映射表 `{file_path: ast_tree}`
- `dependency_order`: 依赖顺序

---

## 阶段四：规则提取 (RuleExtractorComp) ★ 核心阶段

### 输入
- `ast_map`: AST 映射表
- `dependency_order`: 依赖顺序

### 处理逻辑

#### 4.1 结构提取
| 提取内容 | 识别方式 |
|---------|---------|
| 状态类 | `TypedDict` 子类，名称含 `State` |
| 节点函数 | `add_node()` 调用中注册的函数 |
| 边连接 | `add_edge()` / `add_conditional_edges()` 调用 |
| 工具函数 | `@tool` 装饰器 |
| LLM 配置 | `ChatOpenAI` 等 LLM 类实例化 |
| 全局变量 | 模块级变量赋值 |
| 初始输入 | `app.invoke({...})` 调用参数 |
| 示例输入 | `if __name__ == "__main__"` 块中的变量 |

#### 4.2 代码转换规则

| 规则 | LangGraph | openJiuwen |
|------|-----------|------------|
| 状态读取 | `state["key"]` | `inputs["key"]` 或 `runtime.get_global_state("key")` |
| 状态写入 | `state["key"] = val` | 收集到 `return {"key": val}` |
| LLM 调用 | `llm.invoke(msgs)` | `await self._llm.ainvoke(model_name, msgs)` |
| 工具调用 | `tool.invoke({...})` | `tool.invoke(inputs={...})` |
| 工具映射调用 | `tool_map[key].run(arg)` | `invoke_tool(key, arg)` |
| 返回状态 | `return state` | `return {"key1": val1, ...}` |
| 结束标记 | `return END` | `return "end"` |

#### 4.3 全局状态访问规则

| 变量类型 | 访问方式 |
|---------|---------|
| 工作流初始输入 (`input`, `is_end`, `loop_count`) | `runtime.get_global_state("key")` |
| 上游组件通过 `inputs_schema` 传递的字段 | `inputs.get("key")` |

#### 4.4 全局状态更新

```python
# 组件中更新全局状态（确保所有组件都能访问）
runtime.update_global_state({"is_end": is_end, "loop_count": loop_count})
return {"is_end": is_end, "loop_count": loop_count}
```

### 输出
- `extraction_result`: 包含已转换的节点、边、工具、待处理项等

---

## 阶段五：待处理检查 (PendingCheckComp)

### 输入
- `extraction_result`: 提取结果

### 处理逻辑
1. 检查 `extraction_result.pending_items` 是否为空
2. 设置 `has_pending` 标志

### 输出
- `extraction_result`: 透传
- `has_pending`: 是否有待处理项

### 路由函数

```python
def pending_router(runtime: WorkflowRuntime) -> str:
    has_pending = runtime.get_global_state("checker.has_pending")
    return "ai" if has_pending else "ir_builder_direct"
```

---

## 阶段六：AI 语义理解 (AISemanticComp) [可选]

### 输入
- `extraction_result`: 提取结果

### 处理逻辑
1. 遍历 `pending_items`
2. 为每个待处理项构建精确的 Prompt
3. 调用 LLM 获取转换后的代码
4. 更新 `extraction_result`

### Prompt 模板
```
## 上下文
- 状态字段: {state_fields}
- 可用工具: {available_tools}

## 原始代码
{source_code}

## 需要转换的行
{failed_lines}

## 转换规则
1. state["x"] → inputs["x"]
2. state["x"] = val → 收集到返回字典
3. llm.invoke(msgs) → await self._llm.ainvoke(model_name, msgs)

只输出转换后的代码，不要解释。
```

### 输出
- `extraction_result`: 更新后的提取结果

---

## 阶段七：IR 构建 (IRBuilderComp)

### 输入
- `extraction_result`: 提取结果

### 处理逻辑
1. 构建节点 IR (`WorkflowNodeIR`)
2. 构建边 IR (`WorkflowEdgeIR`)，**转换路由函数**
3. 构建工具 IR (`ToolIR`)
4. 构建 LLM 配置 IR (`LLMConfigIR`)
5. 组装 Agent IR 和 Workflow IR

### 路由函数转换规则

| 场景 | 转换方式 |
|------|---------|
| 访问上游组件 return 的字段 | `runtime.get_global_state("node.field")` 带前缀 |
| 访问全局状态（非上游输出） | `runtime.get_global_state("field")` 不带前缀 |

```python
# 示例：judge 组件输出 {"is_end": is_end}
# judge_router 中：
if runtime.get_global_state("judge.is_end"):  # ← 带前缀（judge 的输出）
    return "end"
if (runtime.get_global_state("loop_count") or 0) >= 3:  # ← 不带前缀（全局状态）
    return "end"
```

### 输出
- `agent_ir`: Agent IR
- `workflow_ir`: Workflow IR
- `migration_ir`: 完整迁移 IR

---

## 阶段八：代码生成 (CodeGeneratorComp)

### 输入
- `agent_ir`: Agent IR
- `workflow_ir`: Workflow IR
- `output_dir`: 输出目录
- `is_multi_file`: 是否多文件项目

### 处理逻辑

#### 8.1 生成文件结构
```
{agent_name}/
├── __init__.py
├── config.py
├── tools.py
├── components/{node}_comp.py
├── routers.py
├── workflow.py
└── main.py
```

#### 8.2 config.py 生成
- SSL 配置
- 全局变量（LLM 配置、其他变量）
- `get_llm()` 函数

#### 8.3 tools.py 生成
- 工具函数（@tool 装饰器）
- 工具映射变量 (`tool_map`)
- `invoke_tool()` 辅助函数

```python
def invoke_tool(tool_name: str, arg: str) -> str:
    """调用工具的辅助函数"""
    tool_func = tool_map.get(tool_name)
    if tool_func is None:
        return f"未知工具: {tool_name}"
    if hasattr(tool_func, "params") and tool_func.params:
        param_name = tool_func.params[0].name
    else:
        param_name = "input"
    return tool_func.invoke(inputs={param_name: arg})
```

#### 8.4 组件文件生成
- 类定义 (`WorkflowComponent`, `ComponentExecutable`)
- 初始化方法（LLM 实例）
- `invoke` 方法（转换后的代码）
- 全局状态更新

```python
class JudgeComp(WorkflowComponent, ComponentExecutable):
    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        # 读取全局状态
        input_text = runtime.get_global_state("input")
        # 读取上游传递
        selected_tool = inputs.get("selected_tool")
        # ... 业务逻辑 ...
        # 更新全局状态
        runtime.update_global_state({"is_end": is_end})
        return {"is_end": is_end}
```

#### 8.5 routers.py 生成
- 路由函数定义
- 正确的状态访问方式

#### 8.6 workflow.py 生成
- 工作流构建函数
- inputs_schema 定义
- 组件连接

#### 8.7 main.py 生成
- 主入口函数
- **使用源代码中的示例输入**（从 `example_inputs` 获取）

### 输出
- `generated_files`: 生成的文件列表
- `generated_code`: 生成的代码

---

## 阶段九：报告生成 (ReportComp)

### 输入
- `extraction_result`: 提取结果
- `generated_files`: 生成的文件列表
- `migration_ir`: 迁移 IR

### 处理逻辑
1. 统计规则处理 / AI 处理数量
2. 列出节点、边、工具详情
3. 生成 Markdown 格式报告

### 输出
- `report`: 迁移报告
- `generated_files`: 生成的文件列表

---

## 转换规则汇总

### 代码转换

| LangGraph | openJiuwen |
|-----------|------------|
| `state["key"]` | `inputs["key"]` 或 `runtime.get_global_state("key")` |
| `state.get("key", default)` | `inputs.get("key", default)` 或 `(runtime.get_global_state("key") or default)` |
| `state["key"] = val` | 收集到 `return {"key": val}` |
| `llm.invoke(msgs)` | `await self._llm.ainvoke(model_name=self.model_name, messages=msgs)` |
| `tool.invoke({"arg": val})` | `tool.invoke(inputs={"arg": val})` |
| `tool_map[key].run(arg)` | `invoke_tool(key, arg)` |
| `return state` | `return {"key1": val1, ...}` |
| `return END` | `return "end"` |

### 路由函数转换

| 场景 | 转换方式 |
|------|---------|
| 上游组件输出的字段 | `runtime.get_global_state("node.field")` |
| 全局状态变量 | `runtime.get_global_state("field")` |

---

*由 LG2Jiuwen 迁移工具方案文档*
