openJiuwen支持定义组件的输入输出格式。当把组件添加到工作流时，可配置组件的输入输出格式要求，也可对组件的输入输出进行格式化，确保工作流中数据传递的标准化。

openJiuwen提供了以下两种数据格式化方式：

- 配置`schema`：通过dict来指定组件输入输出的key和value。添加组件到工作流时，可根据组件能力及与上游组件的连接方式，按需配置`inputs_schema/stream_inputs_schema`；也可根据组件能力及与下游组件的连接方式，按需配置`output_schema/stream_output_schema`。适用于数据结构较为简单、明确的场景。
- 配置`transformer`：通过定义转换器函数，以访问上下文中已执行节点的输出结果，并将其转换为当前组件的输入或重新构造其输出。其适用于用户需进行更复杂的数据处理，如数据校验、字段拼接、结构重组和逻辑判断等场景。

   添加组件到工作流时，可根据组件能力与上游组件、下游组件的连接方式，指定输入和输出数据格式格式：
    - 与上游组件连接：配置inputs_transformer，指定批式输入数据格式。 
    - 与下游组件连接：配置outputs_transformer，指定批式输出数据格式。


# 通过配置schema定义组件输入输出格式

schema是一种组件输入输出的结构描述：

- 输入：
    - 若和前序组件为普通连接，可配置`inputs_schema`。
    - 若和前序组件为流式连接，可配置`stream_inputs_schema`。
    - 若和前序组件既有普通连接又有流式连接，可同时配置`inputs_schema`和`stream_inputs_schema`。
- 输出： 
    - 若和后序组件为普通连接，可配置`output_schema`。
    - 若和后序组件为流式连接，可配置`stream_output_schema`。
    - 若和后序组件既有普通连接又有流式连接，可同时配置`output_schema`和`stream_output_schema`。

## 配置输入schema

- 以开始组件和结束组件之间的普通连接为例，结束组件可通过`${start.query}`的方式引用开始组件的`query`参数：
  
  ```python
  from openjiuwen.core.component.end_comp import End
  from openjiuwen.core.workflow.base import Workflow

  workflow = Workflow()
  workflow.set_end_comp("end", End(), inputs_schema={"query": "${start.query}"})
  workflow.add_connection("start", "end")
  ```
- 若和前序组件是流式连接，以大模型组件和结束组件之间的流式连接为例：
  
  ```python
  from openjiuwen.core.component.end_comp import End
  from openjiuwen.core.workflow.base import Workflow
  
  workflow = Workflow()
  # 注册end组件时，指定流式连接输入定义stream_inputs_schema
  workflow.set_end_comp("end_stream", End(), stream_inputs_schema={"data": "${llm.output}"})
  # 添加流式连接：从"llm"指向"end"，其中大模型组件默认实现了`stream`接口，end组件默认实现了`transform`和`collect`接口
  workflow.add_stream_connection("llm", "end_stream")
  ```
- 若和前序组件既有普通连接又有流式连接，以结束组件为例，其与开始组件是普通连接，与大模型组件是流式连接。其普通连接输入schema：
  
  ```python
  end_inputs_schema = {
      "query": "${inputs.userInput}"
  }
  ```
  
  流式连接输入schema：
  
  ```python
  end_stream_inputs_schema = {
      "llm_output": "${llm.output}"
  }
  ```
  
  定义`inputs_schema`后，将结束组件添加到工作流，end组件的批输入`query`引用用户输入的`userInput`，流输入`llm_output`引用大模型组件输出的`output`：
  
  ```python
  from openjiuwen.core.component.end_comp import End
  from openjiuwen.core.workflow.base import Workflow
  
  workflow = Workflow()
  workflow.set_end_comp("end", End(), inputs_schema=end_inputs_schema,stream_inputs_schema=end_stream_inputs_schema)
  workflow.add_connection("start", "end")
  workflow.add_stream_connection("llm", "end")
  ```

## 配置输出schema

- 若和后序组件是普通连接，组件a的invoke方法的返回值`invoke_value`通过outputs_schema格式化为`invoke_output`，后序组件b通过`${a.invoke_output}`获取到组件a的返回值：
  
  ```python
  from openjiuwen.core.component.base import WorkflowComponent
  from openjiuwen.core.context_engine.base import Context
  from openjiuwen.core.runtime.base import ComponentExecutable, Input, Output
  from openjiuwen.core.runtime.runtime import Runtime
  from openjiuwen.core.workflow.base import Workflow
  from openjiuwen.core.workflow.workflow_config import ComponentAbility

  class InvokeCompNode(ComponentExecutable, WorkflowComponent):
      def __init__(self, node_id: str = ''):
          super().__init__()
          self.node_id = node_id

      async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
          if inputs and "value" in inputs:
              return {"value": inputs["value"] * 2}  # 组件实际返回的字段名为"value"
          return {"value": 0}  # 组件实际返回的字段名为"value"
  
  workflow = Workflow()
  # 注册实现invoke能力的源组件a，将其返回的"value"字段格式化为"invoke_output"
  workflow.add_workflow_comp("a", InvokeCompNode("a"), inputs_schema={"value": "${start.a}"},
                            outputs_schema={"invoke_output": "${value}"},  # "${value}"引用组件a实际返回的"value"字段
                            comp_ability=[ComponentAbility.INVOKE])
  workflow.add_workflow_comp("b", InvokeCompNode("b"), inputs_schema={"value": "${a.invoke_output}"},
                            comp_ability=[ComponentAbility.INVOKE])
  workflow.add_connection("a", "b")
  ```
- 若和后序组件是流式连接，组件a的stream方法的返回值`stream_value`通过stream_outputs_schema格式化为`stream_output`，后序组件b通过`${a.stream_output}`获取到组件a的返回值：
  
  ```python
  from typing import AsyncIterator

  from openjiuwen.core.common.logging import logger
  from openjiuwen.core.component.base import WorkflowComponent
  from openjiuwen.core.context_engine.base import Context
  from openjiuwen.core.runtime.base import ComponentExecutable, Input, Output
  from openjiuwen.core.runtime.runtime import Runtime
  from openjiuwen.core.workflow.base import Workflow
  from openjiuwen.core.workflow.workflow_config import ComponentAbility

  class StreamCompNode(ComponentExecutable, WorkflowComponent):
      def __init__(self, node_id: str = ''):
          super().__init__()
          self.node_id = node_id

      async def stream(self, inputs: Input, runtime: Runtime, context: Context) -> AsyncIterator[Output]:
          if inputs and "value" in inputs:
              # 生成两条流式数据帧
              for i in range(1, 3):
                  yield {"value": inputs["value"] * i}  # 组件实际返回的字段名为"value"

  # 实现transform能力的组件，对流数据进行逐帧处理
  class TransformCompNode(ComponentExecutable, WorkflowComponent):
      def __init__(self, node_id: str = ''):
          super().__init__()
          self.node_id = node_id

      async def transform(self, inputs: Input, runtime: Runtime, context: Context) -> AsyncIterator[Output]:
          try:
              value_generator = inputs.get("value")
              async for value in value_generator:
                  logger.debug(f"===TransformCompNode[{self.node_id}], processed input: {value}")
                  yield {"value": value + 100}
          except Exception as e:
              logger.error(f"===TransformCompNode[{self.node_id}], error in transform: {e}")
              raise
  
  workflow = Workflow()
  # 注册实现stream能力的源组件a，将其返回的"value"字段格式化为"stream_output"
  workflow.add_workflow_comp("a", StreamCompNode("a"), inputs_schema={"value": "${start.a}"},
                            stream_outputs_schema={"stream_output": "${value}"},  # "${value}"引用组件a实际返回的"value"字段
                            comp_ability=[ComponentAbility.STREAM], wait_for_all=True)
  workflow.add_workflow_comp("b", TransformCompNode("b"), stream_inputs_schema={"value": "${a.stream_output}"},
                            comp_ability=[ComponentAbility.TRANSFORM], wait_for_all=True)
  workflow.add_stream_connection("a", "b")
  ```
- 若和后序组件既有普通连接又有流式连接，组件a的stream方法的返回值`stream_value`通过stream_outputs_schema格式化为`stream_output`，后序组件b通过`${a.stream_output}`获取到组件a的返回值，后序组件c通过`${a.invoke_output}`获取到组件c的返回值：
  
  ```python
  from typing import AsyncIterator

  from openjiuwen.core.common.logging import logger
  from openjiuwen.core.component.base import WorkflowComponent
  from openjiuwen.core.context_engine.base import Context
  from openjiuwen.core.runtime.base import ComponentExecutable, Input, Output
  from openjiuwen.core.runtime.runtime import Runtime
  from openjiuwen.core.workflow.base import Workflow
  from openjiuwen.core.workflow.workflow_config import ComponentAbility

  # 实现invoke能力的组件，用于批处理
  class InvokeCompNode(ComponentExecutable, WorkflowComponent):
      def __init__(self, node_id: str = ''):
          super().__init__()
          self.node_id = node_id

      async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
          if inputs and "value" in inputs:
              # 简单实现：将输入值加倍
              return {"value": inputs["value"] * 2}
          return {"value": 0}


  # 实现stream能力的组件，将批输入转换为流式输出
  class StreamCompNode(ComponentExecutable, WorkflowComponent):
      def __init__(self, node_id: str = ''):
          super().__init__()
          self.node_id = node_id

      async def stream(self, inputs: Input, runtime: Runtime, context: Context) -> AsyncIterator[Output]:
          if inputs and "value" in inputs:
              # 生成两条流式数据帧
              for i in range(1, 3):
                  yield {"value": inputs["value"] * i}  # 组件实际返回的字段名为"value"


  # 实现transform能力的组件，对流数据进行逐帧处理
  class TransformCompNode(ComponentExecutable, WorkflowComponent):
      def __init__(self, node_id: str = ''):
          super().__init__()
          self.node_id = node_id

      async def transform(self, inputs: Input, runtime: Runtime, context: Context) -> AsyncIterator[Output]:
          try:
              value_generator = inputs.get("value")
              async for value in value_generator:
                  yield {"value": value + 100}
          except Exception as e:
              logger.error(f"===TransformCompNode[{self.node_id}], error in transform: {e}")
              raise

  workflow = Workflow()
  workflow.add_workflow_comp("a", StreamCompNode("a"), inputs_schema={"value": "${start.a}"},
                            outputs_schema={"invoke_output": "${value}"},  # "${value}"引用组件a实际返回的"value"字段
                            stream_outputs_schema={"stream_output": "${value}"},  # "${value}"引用组件a实际返回的"value"字段
                            comp_ability=[ComponentAbility.STREAM, ComponentAbility.INVOKE], wait_for_all=True)
  workflow.add_workflow_comp("b", TransformCompNode("b"), stream_inputs_schema={"value": "${a.stream_output}"},
                            comp_ability=[ComponentAbility.TRANSFORM], wait_for_all=True)
  workflow.add_workflow_comp("c", InvokeCompNode("c"), inputs_schema={"value": "${a.invoke_output}"},
                            comp_ability=[ComponentAbility.INVOKE])
  workflow.add_stream_connection("a", "b")
  workflow.add_connection("a", "c")
  ```

# 通过配置transformer定义组件输入输出格式

transformer是一种用于自定义数据格式化的接口，添加组件到工作流时，可通过`inputs_transformer`指定输入数据格式，`outputs_transformer`指定输出数据格式，用于处理批数据。transformer支持添加自定义字段返回，还支持执行更复杂的数据处理操作（如数据校验、字段拼接、结构重组、逻辑判断等），从而灵活地满足各种数据处理需求。下面主要以`inputs_transformer`和`outputs_transformer`为例介绍与`schema`的区别。

## 配置输入transformer

`inputs_transformer`自定义了组件输入数据的结构和格式，接口输入涵盖当前组件在工作流之前所有组件的输出数据，接口输出为格式化后的输入数据。用户可使用`inputs_transformer`来生成组件的输入，支持执行更复杂的数据处理操作，如数据校验、字段拼接、结构重组和逻辑判断等。

大模型组件的`inputs_transformer`定义如下，若输入为空，则设置默认输入：

```python
from openjiuwen.core.runtime.state import ReadableStateLike

def llm_inputs_transformer(state: ReadableStateLike):
    query = state.get("start.query")
    if query:
        return {"query": query}
    return {"query": "默认输入"}  # 设置默认输入
```

将大模型组件添加到工作流，设置组件id是`llm`，并指定其`inputs_transformer`：

```python
from openjiuwen.core.component.llm_comp import LLMComponent
from openjiuwen.core.workflow.base import Workflow

workflow = Workflow()
workflow.add_workflow_comp("llm", LLMComponent(),
                           inputs_transformer=llm_inputs_transformer)
```

执行工作流时，若Start组件输出为`{"query": "在北京预定酒店"}`，大模型组件的输入引用Start组件的`query`字段，因此大模型组件最终输入为`{"query": "在北京预定酒店"}`；若Start组件没有query字段，则大模型最终输入为`{"query": "默认输入"}`。

## 配置输出transformer

`outputs_transformer`自定义了组件输出数据的结构和格式，接口输入为当前组件的所有输出，接口输出为格式化后的输出数据。用户可使用`outputs_transformer`来格式化组件的输出，支持执行更复杂的数据处理操作，如数据转换、字段提取、结构重组和结果过滤等。

大模型组件的`outputs_transformer`定义如下，若输出为空，则设置默认输出：

```python
def llm_outputs_transformer(results: dict):
    output = results.get("output", None)
    if output:
        return {"result": output}
    return {"result": "默认输出"}
```

将大模型组件添加到工作流，设置组件id是`llm`，并指定其`inputs_transformer`和`outputs_transformer`：

```python
from openjiuwen.core.component.llm_comp import LLMComponent
from openjiuwen.core.workflow.base import Workflow
from openjiuwen.core.runtime.state import ReadableStateLike

def llm_inputs_transformer(state: ReadableStateLike):
    query = state.get("start.query")
    if query:
        return {"query": query}
    return {"query": "默认输入"}

def llm_outputs_transformer(results: dict):
    output = results.get("output", None)
    if output:
        return {"result": output}
    return {"result": "默认输出"}

workflow = Workflow()
workflow.add_workflow_comp("llm", LLMComponent(),
                           inputs_transformer=llm_inputs_transformer,
                           outputs_transformer=llm_outputs_transformer)
```

若大模型组件的输出为`{"output": "北京饭店"}`，则格式化的输出结果为`{"result" : "北京饭店"}`；若大模型组件的输出为`{"output": None}`，则格式化的输出结果为`{"result" : "默认输出"}`。
