组件在工作流中的编排与能力调用，取决于其两端所连接边的类型。工作流会根据组件的输入和输出是流式边还是批边，自动决定以 `​invoke`、​`stream`、​`transform`​还是 ​`collect`​模式运行组件。此外，在工作流的编排中，组件间的数据引用方式也直接影响着数据在工作流中的传递路径与依赖关系。以下将详细介绍组件间的连接方式和数据传递方式。

# 组件间连接方式

在工作流中，组件的连接方式与它所具备的能力是相互影响、相互制约的。​组件的连接方式决定了工作流会调用它的哪一种具体能力。组件自身支持的能力也限制了它如何被连接。不同能力对应特定的流式I/O连接规则如下：

- 当某组件A实现`invoke`能力时，组件A使用`add_connection`与前序组件、后续组件进行连接。
- 当某组件A实现`stream`能力时，组件A使用`add_connection`与前序组件进行连接，使用`add_stream_connection`与后续组件进行连接。
- 当某组件A实现`transform`能力时，组件A使用`add_stream_connection`与前序组件、后续组件进行连接。
- 当某组件A实现`collect`能力时，组件A使用`add_stream_connection`与前序组件进行连接，使用`add_connection`与后续组件进行连接。

下面将引入三个自定义组件`StreamCompNode`、`TransformCompNode`和`CollectCompNode`，根据组件实现的不同能力，选择不同的连边方式，从而实现流式编排。

`StreamCompNode`实现`stream`方法（对应`ComponentAbility.STREAM`），将批输入转换为流式输出。具体为，接收单个输入值（如`{"value": 1}`），生成两条流式数据帧（`{"value": 1 * 1}`和`{"value": 1 * 2}`）。`StreamCompNode`使用`add_connection`与前序组件进行连接，使用`add_stream_connection`与后续组件进行连接。示例代码如下：

```python
import asyncio
from typing import AsyncIterator

from openjiuwen.core.common.logging import logger
from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.graph.executable import Input, Output
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.runtime.base import ComponentExecutable
from openjiuwen.core.runtime.runtime import Runtime

class StreamCompNode(ComponentExecutable, WorkflowComponent):
    def __init__(self, node_id: str = ''):
        super().__init__()
        self.node_id = node_id

    async def stream(self, inputs: Input, runtime: Runtime, context: Context) -> AsyncIterator[Output]:
        logger.debug(f"===StreamCompNode[{self.node_id}], input: {inputs}")
        if inputs is None:
            yield 1
        else:
            for i in range(1, 3):
                yield {"value": i * inputs["value"]}
```

`TransformCompNode`实现`transform`方法（对应`ComponentAbility.TRANSFORM`），对流数据进行逐帧处理。具体为，接收流式输入（如`{"value":1}`,`{"value":2}`），对每帧数据透传处理（实际可添加格式转换逻辑）。`TransformCompNode`使用`add_stream_connection`与前序组件、后续组件进行连接。示例代码如下：

```python
import asyncio
from typing import AsyncIterator
from openjiuwen.core.common.logging import logger
from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.graph.executable import Input, Output
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.runtime.base import ComponentExecutable
from openjiuwen.core.runtime.runtime import Runtime

class TransformCompNode(ComponentExecutable, WorkflowComponent):
    def __init__(self, node_id: str = ''):
        super().__init__()
        self.node_id = node_id

    # inputs是generator字典
    async def transform(self, inputs: Input, runtime: Runtime, context: Context) -> AsyncIterator[
        Output]:
        logger.debug(f"===TransformCompNode[{self.node_id}], input stream started")
        try:
            # 假设key是value，取对应generator
            value_generator = inputs.get("value")
            async for value in value_generator:
                logger.debug(f"===TransformCompNode[{self.node_id}], processed input: {value}")
                yield {"value": value}
        except Exception as e:
            logger.error(f"===TransformCompNode[{self.node_id}], critical error in transform: {e}")
            raise  # 重新抛出关键异常（如流中断）
```

`CollectCompNode`实现`collect`方法（对应`ComponentAbility.COLLECT`），将流输入聚合为批输出。具体为，接收输入流数据`[{"value":1}, {"value":2}]`，聚合计算 1+2，输出批结果`{"value":3}`。`CollectCompNode`使用`add_stream_connection`与前序组件进行连接，使用`add_connection`与后续组件进行连接。示例代码如下：

```python
import asyncio
from typing import AsyncIterator
from openjiuwen.core.common.logging import logger
from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.graph.executable import Input, Output
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.runtime.base import ComponentExecutable
from openjiuwen.core.runtime.runtime import Runtime

class CollectCompNode(ComponentExecutable, WorkflowComponent):
    def __init__(self, node_id: str = ''):
        super().__init__()
        self.node_id = node_id

    # inputs是generator字典
    async def collect(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        logger.info(f"===CollectCompNode[{self.node_id}], input stream started")
        result = 0
        try:
            # 假设key是value，取对应generator
            value_generator = inputs.get("value")
            async for value in value_generator:
                if value is None:
                    logger.warning(f"===CollectCompNode[{self.node_id}], missing 'value' in input: {input}")
                    continue
                result += value
                logger.info(f"===CollectCompNode[{self.node_id}], processed input: {input}")
            return {"value": result}
        except Exception as e:
            logger.error(f"===CollectCompNode[{self.node_id}], critical error in collect: {e}")
            raise  # 重新抛出关键异常，如流中断
```

构建工作流，设置开始和结束组件，将上面三个组件加入到工作流中：

```python
from openjiuwen.core.workflow.base import Workflow
from openjiuwen.core.component.start_comp import Start
from openjiuwen.core.component.end_comp import End
from openjiuwen.core.workflow.workflow_config import ComponentAbility

flow = Workflow()
flow.set_start_comp("start", Start({}), inputs_schema={"a": "${a}"})
# a: throw 2 frames: {value: 1}, {value: 2}
flow.add_workflow_comp("a", StreamCompNode("a"), inputs_schema={"value": "${start.a}"})
# b: transform 2 frames to c
flow.add_workflow_comp("b", TransformCompNode("b"), stream_inputs_schema={"value": "${a.value}"})
# c: value = sum(value of frames)
flow.add_workflow_comp("c", CollectCompNode("c"), stream_inputs_schema={"value": "${b.value}"})
flow.set_end_comp("end", End({}), inputs_schema={"result": "${c.value}"})
```

连接组件，流式组件之间用`add_stream_connection`连接：

```python
flow.add_connection("start", "a")
flow.add_stream_connection("a", "b")
flow.add_stream_connection("b", "c")
flow.add_connection("c", "end")
```

执行工作流：

```python
import asyncio
from openjiuwen.core.runtime.workflow import WorkflowRuntime
result = asyncio.run(flow.invoke({"a": 1}, WorkflowRuntime()))
print(f"{result}")
```

执行结果：

```python
result={'output': {'result': 3}} state=<WorkflowExecutionState.COMPLETED: 'COMPLETED'>
```

# 组件间数据传递方式

在工作流的构建过程中，可通过引用表达式的方式进行组件间的数据传递。引用表达式可引用变量、输入或输出的值，不支持添加逻辑。

## 后续组件引用输入

假设输入为`{"inputs": "test"}`，则后序组件可通过`${inputs}`的方式引用输入。

```python
from openjiuwen.core.component.end_comp import End
from openjiuwen.core.workflow.base import Workflow
from openjiuwen.core.component.start_comp import Start

workflow = Workflow()
workflow.set_start_comp("start", Start(), inputs_schema={"query": "${inputs}"})
```

假设输入为`{"inputs": {"a": 1}}`，则后序组件可通过`${inputs.a}`的方式引用输入。

```python
workflow.set_start_comp("start", Start(), inputs_schema={"query": "${inputs.a}"})
```

## 后序组件引用前序组件

可通过`${<前序组件id>.<输出值id>}`的方式引用前序组件的输出。假设前序组件输出为`{"query": "result"}`，添加到工作流的id是`start`，则后序组件可通过`${start.query}`的方式引用。

```python
workflow.set_end_comp("end", End(), inputs_schema={"query": "${start.query}"})
```


下面是一个完整可运行的示例，展示了如何使用引用表达式进行组件间数据传递：

```python
import asyncio
from openjiuwen.core.component.start_comp import Start
from openjiuwen.core.component.end_comp import End
from openjiuwen.core.workflow.base import Workflow
from openjiuwen.core.runtime.workflow import WorkflowRuntime

# 创建工作流
workflow = Workflow()

# 设置Start组件，演示引用简单输入和嵌套输入
# inputs_schema中的${inputs}引用整个输入对象
# ${inputs.message}引用输入对象中的message字段
workflow.set_start_comp(
    "start", 
    Start(), 
    inputs_schema={
        "query": "${inputs.message}",  # 引用嵌套输入
        "metadata": "${inputs}"         # 引用整个输入
    }
)

# 设置End组件，演示引用前序组件的输出
# ${start.query}引用id为"start"的组件的query输出
# ${start.metadata}引用id为"start"的组件的metadata输出
workflow.set_end_comp(
    "end", 
    End({"responseTemplate": "处理结果: {{result}}, 元数据: {{meta}}"}),
    inputs_schema={
        "result": "${start.query}",      # 引用前序组件的输出
        "meta": "${start.metadata}"      # 引用前序组件的输出
    }
)

# 连接组件
workflow.add_connection("start", "end")

# 执行工作流
inputs = {
    "inputs": {
        "message": "Hello, openJiuwen!"
    }
}

result = asyncio.run(workflow.invoke(inputs=inputs, runtime=WorkflowRuntime()))
print(f"执行结果: {result.result}")
print(f"执行状态: {result.state}")
```

**预期输出：**

```python
执行结果: {'responseContent': "处理结果: Hello, openJiuwen!, 元数据: {'message': 'Hello, openJiuwen!'}"}
执行状态: WorkflowExecutionState.COMPLETED
```
