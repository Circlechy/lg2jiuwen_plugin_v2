记忆引擎（Memory Engine）是openJiuwen框架的核心组件，主要负责智能体记忆信息的管理。它提供了对用户对话内容、会话变量、用户画像等信息的记录、获取、筛选等标准化管理能力，帮助开发者在构建Agent时更高效地处理和利用用户的记忆内容。

在智能对话场景中，用户会产生大量的对话信息，这些信息包含了用户的个人特征、兴趣爱好、行为习惯等有价值的数据。记忆引擎通过智能化的方式管理这些信息，能够帮助Agent更好地理解用户，提供个性化的服务。

记忆引擎的开发流程分为以下两步：

1. 获取记忆引擎实例：通过```create_mem_engine_instance```方法获取记忆引擎实例，支持自定义配置包括是否记录消息、用于生成记忆的AI消息的最大长度、生成记忆的历史窗口等，实现记忆功能的初始化。
2. 使用记忆引擎实例：支持添加对话消息并提取会话变量记忆、用户画像（长期记忆）等信息，同时支持搜索记忆、展示记忆的能力，帮助智能体更好地理解和服务用户。

# 创建记忆引擎实例

通过```create_mem_engine_instance```方法获取记忆引擎实例，需要传入相应的配置参数。配置包括是否记录消息、用于生成记忆的AI消息的最大长度、生成记忆的历史消息窗口大小。另外记忆引擎中的数据存放涉及`kv_store`、`semantic_store`以及关系型数据库，也需要初始化的时候进行注册。在`openjiuwen.core.memory.store.impl`下提供了默认实现，也可以自定义实现，通过继承`openjiuwen.core.memory.store.base_kv_store`中的`BaseKVStore`
,`openjiuwen.core.memory.store.base_semantic_store`中的`BaseSemanticStore`以及`openjiuwen.core.memory.store.base_db_store`。`semantic_store`使用embedding来进行语义相似度的计算，用户可以手动搭建embedding服务或者购买embedding服务。除了配置api_key，url，模型名，模型维度外，建议开启ssl认证，即在环境变量中设置EMBED_SSL_VERIFY为true，另外在EMBED_SSL_CERT中配置证书的路径，保障通信的安全。

下面以使用默认的`DbmKVStore`、`MilvusSemanticStore`和`DefaultDbStore`为例，说明如何创建记忆引擎实例。

```python
import asyncio
import os
from datetime import datetime, timezone
from pathlib import Path

from sqlalchemy.ext.asyncio import create_async_engine

from openjiuwen.core.component.common.configs.model_config import ModelConfig, BaseModelInfo
from openjiuwen.core.memory.config.config import SysMemConfig, MemoryConfig
from openjiuwen.core.memory.engine.memory_engine import MemoryEngine, BaseMemoryEngine
from openjiuwen.core.memory.store.impl.dbm_kv_store import DbmKVStore
from openjiuwen.core.memory.store.impl.milvus_semantic_store import MilvusSemanticStore
from openjiuwen.core.memory.embed_models.api import APIEmbedModel
from openjiuwen.core.memory.store.impl.default_db_store import DefaultDbStore
from openjiuwen.core.utils.llm.messages import BaseMessage

async def run() -> None:
    # 定义系统配置，如果需要加密，可以配置crypto_key参数，具体参考SysMemConfig默认参数配置
    sys_config_dict = {
        "record_message": True,
        "ai_msg_gen_max_len": 64,
        "history_window_size_to_gen_mem": 5,
    }
    sys_config = SysMemConfig(**sys_config_dict)
    # llm相关环境变量和配置
    os.environ["LLM_SSL_VERIFY"] = "false"
    os.environ["RESTFUL_SSL_VERIFY"] = "false"
    os.environ["SSRF_PROTECT_ENABLED"] = "false"
    # embedding相关环境变量配置
    os.environ["EMBED_SSL_VERIFY"] = "false"
    
    base_model_config = ModelConfig(
        model_provider="xxx",
        model_info=BaseModelInfo(
            api_key="xxx",
            api_base="xxx",
            model="xxx",
        )
    )
    # 创建mysql数据库
    # 其中db_user表示数据库用户名, db_passport表示数据库密码, db_host表示mysql数据库主机地址, db_port表示mysql数据库端口号, agent_db_name表示数据库名
    db_user = "xxxx"
    db_passport = "xxxx"
    db_host = "xxxx"
    db_port = "xxxx"
    agent_db_name = "xxxx"
    db_engine_instance = create_async_engine(
        f"mysql+aiomysql://{db_user}:{db_passport}@{db_host}:{db_port}/{agent_db_name}?charset=utf8mb4",
        pool_size=20,
        max_overflow=20
    )
    db_store = DefaultDbStore(db_engine_instance)
    # 创建kv数据库
    dbm_test_dir = "test_dbm"
    os.makedirs(dbm_test_dir, exist_ok=True)
    dbm_kv_path = os.path.join(dbm_test_dir, "testdb")
    dbm_kv_store = DbmKVStore(dbm_kv_path)
    # 创建embedding模型
    # model_name表示使用的embedding模型名, base_url表示请求embedding API的地址, api_key表示密钥, max_retries表示最大重试次数, timeout表示请求超时时间
    embed_model = APIEmbedModel(model_name="xxxx", base_url=r'https://xxxx', api_key='xxxx', max_retries=3, timeout=60)
    # 创建milvus Semantic数据库
    # milvus_host表示Milvus服务的主机地址, milvus_port表示milvus服务的端口, token表示用于身份认证的key
    # embed_model表示用来生成向量的客户端实例, collection_name表示存储向量的collection名称, embedding_dims表示向量的维度(向量维度必须与embed_model的输出维度一致)
    sem_store = MilvusSemanticStore(milvus_host="xxxx", milvus_port="xxxx", token="xxxx", embed_model=embed_model, collection_name="xxxx", embedding_dims=1024)
    # 注册数据库并创建记忆引擎实例
    memory_engine = await MemoryEngine.register_store(kv_store=dbm_kv_store, semantic_store=sem_store, db_store=db_store).create_mem_engine_instance(sys_config)
    # 设置基础llm配置
    # 记忆引擎接口也提供set_group_llm_config/set_group_llm接口，设置group粒度llm(使用优先级高)                
    memory_engine.init_base_llm(base_model_config)

```

# 使用记忆引擎实例

记忆引擎支持添加对话消息、查询变量记忆和长期记忆、检索与query语义相似度高的记忆以及更新、删除记忆等主要操作。

## 添加消息

通过```add_conversation_messages```方法可以添加对话消息，记忆引擎会分析并提取记忆信息。

```python
user_id = "user1"
group_id = "group1"
mem_config_dict = {
    "mem_variables": {
        "姓名": "用户姓名",
        "职业": "用户职业",
        "居住地": "用户居住地",
        "爱好": "用户爱好"
    },
    "enable_long_term_mem": True,
}
mem_config = MemoryConfig(**mem_config_dict)
memory_engine.set_group_config(group_id, mem_config)

message1 = BaseMessage(role="user",
                       content="我叫张三，我喜欢打羽毛球")
message2 = BaseMessage(role="assistant",
                       content="你好张三，很高兴认识你")

timestamp = datetime.now(timezone.utc)
message_id = await memory_engine.add_conversation_messages(user_id=user_id, group_id=group_id, messages=[message1, message2], timestamp=timestamp)

```

## 查询变量记忆和长期记忆

用户可以通过接口list_user_variables和list_user_mem查询提取到的变量记忆和长期记忆。

```python
# 查询变量记忆
user_variables = await memory_engine.list_user_variables(user_id, group_id)
# 查询长期记忆
user_mem = await memory_engine.list_user_mem(user_id=user_id, group_id=group_id, num=10, page=1)
```

## 检索和query相似度高的记忆信息
用户可以通过接口search_user_mem检索记忆，记忆引擎通过对query进行embedding编码，在生成的记忆中检索语义相似度最高的num条记忆信息。

```python
# 获取用户的爱好
search_hobby = await memory_engine.search_user_mem(user_id=user_id, group_id=group_id, query="用户的爱好", num=1)
```

## 更新变量记忆和长期记忆
用户可以通过接口update_user_variable和update_mem_by_id对变量记忆和长期记忆进行更新。

```python
# 更新变量记忆
await memory_engine.update_user_variable(user_id=user_id, group_id=group_id, name="爱好", value="篮球")
# 更新长期记忆
await memory_engine.update_mem_by_id(user_id=user_id, group_id=group_id, mem_id=mem_id, memory="用户的爱好是篮球")
```

## 删除变量记忆和长期记忆
用户可以通过接口delete_user_variable和delete_mem_by_id对变量记忆和长期记忆进行删除。

```python
# 删除变量记忆
await memory_engine.delete_user_variable(user_id=user_id, group_id=group_id, name="爱好")
# 删除长期记忆
await memory_engine.delete_mem_by_id(user_id=user_id, group_id=group_id, mem_id=mem_id)

```

输出示例

```
user_mem: [{'id': '019b35f578d9d2febbcf474e', ..., 'profile_type': 'personal_information', 'mem': '用户的姓名是张三', ...}, {'id': '019b360491e11ca26f505123', ..., 'profile_type': 'interest_hobbies', 'mem': '用户的兴趣爱好是打羽毛球', ...}]
user_variables: {'姓名': '张三', '爱好': '打羽毛球'}
search_hobby: [{'id': '019b35f578d9d2febbcf474e', ..., 'profile_type': 'personal_information', 'mem': '用户的姓名是张三', ...]
```

# 完整的使用记忆引擎代码示例

```python
import asyncio
import os
from datetime import datetime, timezone
from pathlib import Path

from sqlalchemy.ext.asyncio import create_async_engine

from openjiuwen.core.component.common.configs.model_config import ModelConfig, BaseModelInfo
from openjiuwen.core.memory.config.config import SysMemConfig, MemoryConfig
from openjiuwen.core.memory.engine.memory_engine import MemoryEngine, BaseMemoryEngine
from openjiuwen.core.memory.store.impl.dbm_kv_store import DbmKVStore
from openjiuwen.core.memory.store.impl.milvus_semantic_store import MilvusSemanticStore
from openjiuwen.core.memory.store.impl.default_db_store import DefaultDbStore
from openjiuwen.core.memory.embed_models.api import APIEmbedModel
from openjiuwen.core.utils.llm.messages import BaseMessage


async def run() -> None:
    sys_config_dict = {
        "record_message": True,
        "ai_msg_gen_max_len": 64,
        "history_window_size_to_gen_mem": 5,
    }
    sys_config = SysMemConfig(**sys_config_dict)
    os.environ["LLM_SSL_VERIFY"] = "false"
    os.environ["RESTFUL_SSL_VERIFY"] = "false"
    os.environ["SSRF_PROTECT_ENABLED"] = "false"
    os.environ["EMBED_SSL_VERIFY"] = "false"
    base_model_config = ModelConfig(
        model_provider="xxx",
        model_info=BaseModelInfo(
            api_key="xxx",
            api_base="xxx",
            model="xxx",
        )
    )
    # 创建mysql数据库表
    db_user = "xxxx"
    db_passport = "xxxx"
    db_host = "xxxx"
    db_port = "xxxx"
    agent_db_name = "xxxx"
    db_engine_instance = create_async_engine(
        f"mysql+aiomysql://{db_user}:{db_passport}@{db_host}:{db_port}/{agent_db_name}?charset=utf8mb4",
        pool_size=20,
        max_overflow=20
    )
    db_store = DefaultDbStore(db_engine_instance)

    dbm_test_dir = "test_dbm"
    os.makedirs(dbm_test_dir, exist_ok=True)
    dbm_kv_path = os.path.join(dbm_test_dir, "testdb")
    dbm_kv_store = DbmKVStore(dbm_kv_path)
    # 创建embedding模型
    embed_model = APIEmbedModel(model_name="xxxx", base_url=r'https://xxxx', api_key='xxxx', max_retries=3, timeout=60)
    sem_store = MilvusSemanticStore(milvus_host="xxxx", milvus_port="xxxx", token="xxxx", embed_model=embed_model, collection_name="xxxx", embedding_dims=1024)
    memory_engine = await MemoryEngine.register_store(kv_store=dbm_kv_store, semantic_store=sem_store, db_store=db_store).create_mem_engine_instance(sys_config)
    memory_engine.init_base_llm(base_model_config)

    user_id = "user1"
    group_id = "group1"
    mem_config_dict = {
        "mem_variables": {
            "姓名": "用户姓名",
            "职业": "用户职业",
            "居住地": "用户居住地",
            "爱好": "用户爱好"
        },
        "enable_long_term_mem": True,
    }
    mem_config = MemoryConfig(**mem_config_dict)
    memory_engine.set_group_config(group_id, mem_config)

    message1 = BaseMessage(role="user",
                           content="我叫张三，我喜欢打羽毛球")
    message2 = BaseMessage(role="assistant",
                           content="你好张三，很高兴认识你")

    timestamp = datetime.now(timezone.utc)
    message_id = await memory_engine.add_conversation_messages(user_id=user_id, group_id=group_id, messages=[message1, message2], timestamp=timestamp)
    user_variables = await memory_engine.list_user_variables(user_id, group_id)
    user_mem = await memory_engine.list_user_mem(user_id=user_id, group_id=group_id, num=10, page=1)
    search_hobby = await memory_engine.search_user_mem(user_id=user_id, group_id=group_id, query="用户的爱好", num=1)
    print(f"message_id: {message_id}\n"
          f"user_mem: {user_mem}\n"
          f"user_variables: {user_variables}\n"
          f"search_hobby: {search_hobby}\n")
    
    await memory_engine.update_user_variable(user_id=user_id, group_id=group_id, name="爱好", value="篮球")
    if len(search_hobby) == 1:
        await memory_engine.update_mem_by_id(user_id=user_id, group_id=group_id, mem_id=search_hobby[0]['id'], memory="用户的爱好是篮球")
    user_variables = await memory_engine.list_user_variables(user_id, group_id)
    user_mem = await memory_engine.list_user_mem(user_id=user_id, group_id=group_id, num=10, page=1)
    print(f"after update user_mem: {user_mem}, user_variables: {user_variables}")

    await memory_engine.delete_user_variable(user_id=user_id, group_id=group_id, name="爱好")
    if len(search_hobby) == 1:
        await memory_engine.delete_mem_by_id(user_id=user_id, group_id=group_id, mem_id=search_hobby[0]['id'])
    user_variables = await memory_engine.list_user_variables(user_id, group_id)
    user_mem = await memory_engine.list_user_mem(user_id=user_id, group_id=group_id, num=10, page=1)
    print(f"after delete user_mem: {user_mem}, user_variables: {user_variables}")
    # 释放数据库引擎
    await db_engine_instance.dispose()

    # 关闭嵌入模型中任何打开的aiohttp会话
    if hasattr(embed_model, '_session') and embed_model._session:
        await embed_model._session.close()


if __name__ == '__main__':
    asyncio.run(run())
```
