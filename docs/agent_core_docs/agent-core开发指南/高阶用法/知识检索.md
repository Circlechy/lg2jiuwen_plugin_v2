# 知识检索

知识检索（Retrieval）是openJiuwen框架的核心组件，主要负责知识库的管理和文档检索。它提供了对文档解析、分块、索引构建、向量检索等标准化管理能力，帮助开发者在构建Agent时更高效地处理知识内容。

在智能对话场景中，用户需要从大量文档中快速准确地检索相关信息。知识检索通过向量化、索引化等方式管理这些信息，能够帮助Agent更好地理解上下文，提供准确的答案。

知识检索的开发流程分为以下两步：

1. 创建知识库实例：以```SimpleKnowledgeBase```为例创建知识库实例，支持自定义配置包括向量存储、嵌入模型、文档解析器、文本分块器等，实现知识库功能的初始化。
2. 使用知识库实例：支持添加文档、构建索引、检索文档等主要操作，帮助智能体更好地利用知识内容。

# 创建知识库实例

通过```SimpleKnowledgeBase```创建知识库实例，需要传入相应的配置参数。配置包括知识库ID、索引类型（vector/bm25/hybrid）等。另外知识库中的数据存放涉及向量存储、嵌入模型、索引管理器等，也需要初始化的时候进行配置。在`openjiuwen.core.retrieval`下提供了默认实现，也可以自定义实现。

下面以使用默认的```MilvusVectorStore```、```APIEmbedding```和```MilvusIndexer```为例，说明如何创建知识库实例。

```python
import asyncio

from openjiuwen.core.retrieval.common.config import (
    EmbeddingConfig,
    KnowledgeBaseConfig,
    RetrievalConfig,
    VectorStoreConfig,
)
from openjiuwen.core.retrieval.embedding.api_embedding import APIEmbedding
from openjiuwen.core.retrieval.indexing.indexer.milvus_indexer import MilvusIndexer
from openjiuwen.core.retrieval.indexing.processor.chunker.chunking import TextChunker
from openjiuwen.core.retrieval.indexing.processor.parser.auto_file_parser import AutoFileParser
from openjiuwen.core.retrieval.simple_knowledge_base import SimpleKnowledgeBase
from openjiuwen.core.retrieval.vector_store.milvus_store import MilvusVectorStore


async def create_kb() -> None:
    """创建知识库"""
    # 定义知识库配置
    kb_config = KnowledgeBaseConfig(
        kb_id="test_kb_001",
        index_type="hybrid",  # 支持 vector、bm25、hybrid
        use_graph=False,
        chunk_size=512,
        chunk_overlap=50,
    )

    # 创建向量存储
    # milvus_uri表示Milvus服务的主机地址（默认为http://localhost:19530）, milvus_token为用于身份认证的key（默认为空）
    vector_store_config = VectorStoreConfig(
        collection_name=f"kb_{kb_config.kb_id}_chunks",
        distance_metric="cosine",
    )
    milvus_uri = "http://localhost:19530"
    milvus_token = ""
    vector_store = MilvusVectorStore(
        config=vector_store_config,
        milvus_uri=milvus_uri,
        milvus_token=milvus_token,
    )

    # 创建嵌入模型
    # model_name表示使用的embedding模型名, base_url表示请求embedding API的地址, api_key表示密钥, max_retries表示最大重试次数, timeout表示请求超时时间
    embedding_config = EmbeddingConfig(
        model_name="xxxxx",
        api_key="sk-xxxxx",
        base_url="http://xxxxx",
    )
    embed_model = APIEmbedding(config=embedding_config, max_retries=3, timeout=60)

    # 创建索引管理器
    indexer = MilvusIndexer(
        milvus_uri=milvus_uri,
        milvus_token=milvus_token,
    )

    # 创建文档解析器（自动识别文件格式）
    parser = AutoFileParser()

    # 创建文本分块器
    chunker = TextChunker(
        chunk_size=kb_config.chunk_size,
        chunk_overlap=kb_config.chunk_overlap,
        chunk_unit="token",  # 支持 char 或 token
    )

    # 创建知识库实例
    knowledge_base = SimpleKnowledgeBase(
        config=kb_config,
        vector_store=vector_store,
        embed_model=embed_model,
        parser=parser,
        chunker=chunker,
        index_manager=indexer,
    )

    return knowledge_base
```

# 使用知识库实例

知识库支持添加文档、检索文档、删除文档、更新文档等主要操作。

## 添加文档

通过```parse_files```和```add_documents```方法可以添加文档到知识库，知识库会自动进行文档解析、分块、索引构建等处理。

```python
async def add_documents(knowledge_base: SimpleKnowledgeBase) -> None:
    """添加文档"""
    # 准备文档文件路径
    file_paths = [
        "./documents/doc1.pdf",
        "./documents/doc2.txt",
        "./documents/doc3.md",
    ]

    # 解析文件为Document对象列表
    documents = await knowledge_base.parse_files(file_paths)

    # 添加doc id
    for doc_idx, doc in enumerate(documents, 1):
        doc.id_ = f"doc_id_{doc_idx}"

    # 添加文档到知识库（自动分块和构建索引）
    doc_ids = await knowledge_base.add_documents(documents)
    print(f"成功添加 {len(doc_ids)} 个文档，文档ID: {doc_ids}")
```

## 检索文档

通过```retrieve```方法可以检索相关文档，支持向量检索、稀疏检索和混合检索。

```python
async def retrieval(knowledge_base: SimpleKnowledgeBase) -> None:
    # 配置检索参数
    retrieval_config = RetrievalConfig(
        top_k=3,  # 返回前5个结果
        filters=None,  # 元数据过滤条件（可选）
    )

    # 执行检索
    query = "什么是人工智能？"
    results = await knowledge_base.retrieve(query, config=retrieval_config)

    # 打印检索结果
    for i, result in enumerate(results, 1):
        print(f"\n结果 {i}:")
        print(f"  文本: {result.text[:100]}...")
        print(f"  相似度: {result.score:.4f}")
        print(f"  文档ID: {result.doc_id}")
        print(f"  块ID: {result.chunk_id}")
```

## 删除文档

通过```delete_documents```方法可以删除知识库中的文档。

```python
async def delete_document_id(knowledge_base: SimpleKnowledgeBase) -> None:
    doc_ids_to_delete = ["doc_id_1", "doc_id_2"]
    success = await knowledge_base.delete_documents(doc_ids_to_delete)
    print(f"删除结果: {success}")
```

## 获取统计信息

通过```get_statistics```方法可以获取知识库的统计信息。

```python
# 获取知识库统计信息
stats = await knowledge_base.get_statistics()
print(f"知识库ID: {stats['kb_id']}")
print(f"索引类型: {stats['index_type']}")
print(f"索引信息: {stats['index_info']}")
print(f"组件状态: {stats}")
```

# 完整的使用知识库代码示例

```python
import asyncio

from openjiuwen.core.retrieval.common.config import (
    EmbeddingConfig,
    KnowledgeBaseConfig,
    RetrievalConfig,
    VectorStoreConfig,
)
from openjiuwen.core.retrieval.embedding.api_embedding import APIEmbedding
from openjiuwen.core.retrieval.indexing.indexer.milvus_indexer import MilvusIndexer
from openjiuwen.core.retrieval.indexing.processor.chunker.chunking import TextChunker
from openjiuwen.core.retrieval.indexing.processor.parser.auto_file_parser import AutoFileParser
from openjiuwen.core.retrieval.simple_knowledge_base import SimpleKnowledgeBase
from openjiuwen.core.retrieval.vector_store.milvus_store import MilvusVectorStore


async def create_kb() -> None:
    """创建知识库"""
    # 定义知识库配置
    kb_config = KnowledgeBaseConfig(
        kb_id="test_kb_001",
        index_type="hybrid",  # 支持 vector、bm25、hybrid
        use_graph=False,
        chunk_size=512,
        chunk_overlap=50,
    )

    # 创建向量存储
    # milvus_uri表示Milvus服务的主机地址（默认为http://localhost:19530）, milvus_token为用于身份认证的key（默认为空）
    vector_store_config = VectorStoreConfig(
        collection_name=f"kb_{kb_config.kb_id}_chunks",
        distance_metric="cosine",
    )
    milvus_uri = "http://localhost:19530"
    milvus_token = ""
    vector_store = MilvusVectorStore(
        config=vector_store_config,
        milvus_uri=milvus_uri,
        milvus_token=milvus_token,
    )

    # 创建嵌入模型
    # model_name表示使用的embedding模型名, base_url表示请求embedding API的地址, api_key表示密钥, max_retries表示最大重试次数, timeout表示请求超时时间
    embedding_config = EmbeddingConfig(
        model_name="xxxxx",
        api_key="sk-xxxxx",
        base_url="http://xxxxx",
    )
    embed_model = APIEmbedding(config=embedding_config, max_retries=3, timeout=60)

    # 创建索引管理器
    indexer = MilvusIndexer(
        milvus_uri=milvus_uri,
        milvus_token=milvus_token,
    )

    # 创建文档解析器（自动识别文件格式）
    parser = AutoFileParser()

    # 创建文本分块器
    chunker = TextChunker(
        chunk_size=kb_config.chunk_size,
        chunk_overlap=kb_config.chunk_overlap,
        chunk_unit="token",  # 支持 char 或 token
    )

    # 创建知识库实例
    knowledge_base = SimpleKnowledgeBase(
        config=kb_config,
        vector_store=vector_store,
        embed_model=embed_model,
        parser=parser,
        chunker=chunker,
        index_manager=indexer,
    )

    return knowledge_base


async def add_documents(knowledge_base: SimpleKnowledgeBase) -> None:
    """添加文档"""
    # 准备文档文件路径
    file_paths = [
        "./documents/doc1.pdf",
        "./documents/doc2.txt",
        "./documents/doc3.md",
    ]

    # 解析文件为Document对象列表
    documents = await knowledge_base.parse_files(file_paths)

    # 添加doc id
    for doc_idx, doc in enumerate(documents, 1):
        doc.id_ = f"doc_id_{doc_idx}"

    # 添加文档到知识库（自动分块和构建索引）
    doc_ids = await knowledge_base.add_documents(documents)
    print(f"成功添加 {len(doc_ids)} 个文档，文档ID: {doc_ids}")


async def retrieval(knowledge_base: SimpleKnowledgeBase) -> None:
    # 配置检索参数
    retrieval_config = RetrievalConfig(
        top_k=3,  # 返回前5个结果
        filters=None,  # 元数据过滤条件（可选）
    )

    # 执行检索
    query = "什么是人工智能？"
    results = await knowledge_base.retrieve(query, config=retrieval_config)

    # 打印检索结果
    for i, result in enumerate(results, 1):
        print(f"\n结果 {i}:")
        print(f"  文本: {result.text[:100]}...")
        print(f"  相似度: {result.score:.4f}")
        print(f"  文档ID: {result.doc_id}")
        print(f"  块ID: {result.chunk_id}")
        print(f"  meta: {result.metadata}")


async def delete_document_id(knowledge_base: SimpleKnowledgeBase) -> None:
    doc_ids_to_delete = ["doc_id_1", "doc_id_2"]
    success = await knowledge_base.delete_documents(doc_ids_to_delete)
    print(f"删除结果: {success}")


if __name__ == "__main__":
    kb = asyncio.run(create_kb())
    asyncio.run(add_documents(kb))
    asyncio.run(retrieval(kb))
    asyncio.run(delete_document_id(kb))
```

输出示例

```
1. 添加文档到知识库
   成功添加 2 个文档: ['doc_id_1', 'doc_id_2']

2. 检索相关文档
   查询: 人工智能的应用场景
   找到 3 个相关结果:
     1. 相似度: 0.8523, 文本: 人工智能在医疗、金融、教育等领域有广泛应用...

3. 获取知识库统计信息
   知识库ID: test_kb_001
   索引类型: hybrid
   索引信息: {'exists': True, 'collection_name': 'kb_test_kb_001_chunks', 'count': 15}

4. 更新文档
   成功更新 1 个文档

5. 删除文档
   删除结果: True
```

