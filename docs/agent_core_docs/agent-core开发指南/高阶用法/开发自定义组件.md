openJiuwen提供了灵活而强大的组件开发能力。用户只需继承`WorkflowComponent`抽象类并实现其中的方法，即可快速构建自定义组件。自定义组件一般包含以下功能：

- 处理组件的输入数据，生成组件的输出数据，支持流数据和批数据的处理。
- 为组件定制配套分支的场景。
- 使用`Runtime`提供的能力，包括获取配置信息、更新或获取状态信息、记录trace信息、管理资源、交互中断能力，参考[Runtime](./Runtime/概述.md)。

# 实现自定义组件

openJiuwen支持两种实现自定义组件的方式：

- 同时继承`WorkflowComponent`和`ComponentExecutable`：直接在类中实现`ComponentExecutable`的方法，并在组件的`to_executable`方法中返回`self`。适用于组件功能简单的场景，定义的组件本身就是运行态的实例。
- 继承`WorkflowComponent`：单独编写一个类继承`ComponentExecutable`，并在组件的`to_executable`方法中返回该实例。适用于组件功能相对复杂，构造逻辑和运行逻辑分离的场景。

其中`ComponentExecutable`为执行器的抽象类，主要提供了`invoke`、`stream`、`collect`和`transform`业务处理接口，用户可根据业务需求实现不同的接口。若组件本身涉及到自定义连接配置（例如：意图识别组件、分支组件），需要实现`add_component`方法将自定义组件的运行态`to_executable`和必要的连接关系添加到`Graph`图执行引擎。

以下为通过两种方式实现自定义组件的具体示例，分别是计算节点组件`ComputeComponent`和二进制响应反序列化组件`ResponseHandlerComponent`。

## 同时继承WorkflowComponent和ComponentExecutable

`ResponseHandlerComponent`是用于响应反序列化的自定义组件，同时继承`WorkflowComponent`和`ComponentExecutable`。这种继承实现的方式下，`to_executable`和`add_component`的默认实现是为将组件自身作为`ComponentExecutable`类型的实例并添加到工作流的图执行引擎中。

`ResponseHandlerComponent`实现流式响应的的内容进行逐帧反序列化，通过`transform`方法将反序列化的结果逐帧返回，通过`collect`方法对反序列化完的结果收集后批量返回。

```python
import json
from typing import AsyncIterator

from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.runtime.base import ComponentExecutable, Input, Output
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.runtime.runtime import Runtime


class ResponseHandlerComponent(WorkflowComponent, ComponentExecutable):
    async def transform(self, inputs: Input, runtime: Runtime, context: Context) -> AsyncIterator[Output]:
        """ 处理流式输入，遍历所有输入，每次获取response内容，调用__deserialize__方法对其进行反序列化，并返回一个包含反序列化结果的生成器元素 """
        response_generator = inputs.get("response")
        async for response in response_generator:
            if response is not None:
                yield {"content": self.__deserialize__(content_bytes=response.get("content", None))}

        yield {"status": "finished"}

    async def collect(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        """收集所有解析好的response消息，并批量返回"""
        responses = []
        response_generator = inputs.get("response")

        async for response in response_generator:
            if response is not None:
                responses.append(self.__deserialize__(content_bytes=response.get("content", None)))
        return {"result": responses}

    @staticmethod
    def __deserialize__(content_bytes: bytes):
        """ 反序列化 """
        if content_bytes is None:
            return {}
        return json.loads(content_bytes.decode("utf-8"))
```

- 当工作流调用到`transform`接口，输出结果为3帧数据。

通过`workflow.add_workflow_comp`方法将自定义的`ResponseHandlerComponent`组件添加到工作流中，设置组件id为"handler"，并指定流输入的schema为`"${llm.response}"`：

```python
from openjiuwen.core.workflow.base import Workflow

workflow = Workflow()
workflow.add_workflow_comp("response_handler", ResponseHandlerComponent(),
                           stream_inputs_schema={"response": "${llm.response}"})
```

调用`workflow.stream({"user_inputs": "帮我生成一张小女孩的图片"}, runtime=WorkflowRuntime(), stream_modes=[BaseStreamMode.OUTPUT])`方法执行工作流。工作流执行结果包含如下3帧：

```python
receive chunk:  type='end node stream' index=0 payload={'end_transform': {'response_handler': {'content': {'url': 'http://xxxxx', 'description': '小女孩在公园'}}}}
receive chunk:  type='end node stream' index=1 payload={'end_transform': {'response_handler': {'content': {'url': 'http://xxxxx', 'description': '上学的小女孩'}}}}
receive chunk:  type='end node stream' index=2 payload={'end_transform': {'response_handler': {'content': {'status': 'finished'}}}}
receive chunk:  type='end node stream' index=3 payload={'output': {'end_transform': {'status': 'finished'}}}
```

- 当工作流调用到`collect`接口，输出结果为批数据。
通过`workflow.add_workflow_comp`方法将自定义的`ResponseHandlerComponent`组件添加到工作流中，设置组件id为"handler"，并指定流输入的schema为`"${llm.response}"`，并指定组件的能力为`COLLECT`：

```python
workflow.add_workflow_comp("response_handler", ResponseHandlerComponent(),
                           stream_inputs_schema={"response": "${llm.response}"})
```

调用`workflow.invoke({"user_inputs": "帮我生成一张小女孩的图片"}, runtime=WorkflowRuntime())`方法执行工作流。输出结果如下：

```python
result={'result': {'result': [{'url': 'http://xxxxx', 'description': '小女孩在公园'}, {'url': 'http://xxxxx', 'description': '上学的小女孩'}, {'status': 'finished'}]}} state=<WorkflowExecutionState.COMPLETED: 'COMPLETED'>
```

**完整代码**：

```python
import asyncio
import json
from typing import AsyncIterator

from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.component.end_comp import End
from openjiuwen.core.component.start_comp import Start
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.graph.executable import Output, Input
from openjiuwen.core.runtime.base import ComponentExecutable
from openjiuwen.core.runtime.runtime import Runtime
from openjiuwen.core.runtime.workflow import WorkflowRuntime
from openjiuwen.core.stream.base import BaseStreamMode
from openjiuwen.core.workflow.base import Workflow
from openjiuwen.core.workflow.workflow_config import ComponentAbility

# mock llm组件，并流出3帧数据
class MockLLMComponent(WorkflowComponent, ComponentExecutable):
    def __init__(self):
        super().__init__()
        self.mock_llm_streams = [
            json.dumps({"url": "http://xxxxx", "description": "小女孩在公园"}).encode("utf-8"),
            json.dumps({"url": "http://xxxxx", "description": "上学的小女孩"},).encode("utf-8"),
            json.dumps({"status": "finished"}).encode("utf-8"),
        ]

    async def stream(self, inputs: Input, runtime: Runtime, context: Context) -> AsyncIterator[Output]:
        for stream in self.mock_llm_streams:
            yield {"response": { "content": stream }}

class ResponseHandlerComponent(WorkflowComponent, ComponentExecutable):
    async def transform(self, inputs: Input, runtime: Runtime, context: Context) -> AsyncIterator[Output]:
        """ 处理流式输入，遍历所有输入，每次获取response内容，调用__deserialize__方法对其进行反序列化，并返回一个包含反序列化结果的生成器元素 """
        response_generator = inputs.get("response")
        async for response in response_generator:
            if response is not None:
                yield {"content": self.__deserialize__(content_bytes=response.get("content", None))}

        yield {"status": "finished"}

    async def collect(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        """收集所有解析好的response消息，并批量返回"""
        responses = []
        response_generator = inputs.get("response")

        async for response in response_generator:
            if response is not None:
                responses.append(self.__deserialize__(content_bytes=response.get("content", None)))
        return {"result": responses}

    @staticmethod
    def __deserialize__(content_bytes: bytes):
        """ 反序列化 """
        if content_bytes is None:
            return {}
        return json.loads(content_bytes.decode("utf-8"))

# 触发transform功能
async def run_transform_workflow():
    workflow = Workflow()
    workflow.set_start_comp("s", Start())
    workflow.add_workflow_comp("llm", MockLLMComponent(), inputs_schema={"query": "${user_inputs}"},
                               comp_ability=[ComponentAbility.STREAM], wait_for_all=True)
    workflow.add_workflow_comp("response_handler", ResponseHandlerComponent(),
                               comp_ability=[ComponentAbility.TRANSFORM],
                               stream_inputs_schema={"response": "${llm.response}"},
                               wait_for_all=True)
    workflow.set_end_comp("e", End(), response_mode="streaming",
                          stream_inputs_schema={"end_transform": "${response_handler}"})

    workflow.add_connection("s", "llm")
    workflow.add_stream_connection("llm", "response_handler")
    workflow.add_stream_connection("response_handler", "e")
    async for chunk in workflow.stream({"user_inputs": "帮我生成一张小女孩的图片"}, runtime=WorkflowRuntime(),
                                       stream_modes=[BaseStreamMode.OUTPUT]):
        print("receive chunk: ", chunk)

# 触发collect功能
async def run_collect_workflow():
    workflow = Workflow()
    workflow.set_start_comp("s", Start())
    workflow.add_workflow_comp("llm", MockLLMComponent(), inputs_schema={"query": "${user_inputs}"},
                               comp_ability=[ComponentAbility.STREAM], wait_for_all=True)
    workflow.add_workflow_comp("response_handler", ResponseHandlerComponent(),
                               comp_ability=[ComponentAbility.COLLECT],
                               stream_inputs_schema={"response": "${llm.response}"},
                               wait_for_all=True)
    workflow.set_end_comp("e", End(), inputs_schema={"result": "${response_handler}"})

    workflow.add_connection("s", "llm")
    workflow.add_stream_connection("llm", "response_handler")
    workflow.add_connection("response_handler", "e")
    output = await workflow.invoke({"user_inputs": "帮我生成一张小女孩的图片"}, runtime=WorkflowRuntime())
    print(output)

if __name__ == "__main__":
    asyncio.run(run_transform_workflow())
    asyncio.run(run_collect_workflow())
```

输出结果为：

```python
receive chunk:  type='end node stream' index=0 payload={'output': {'end_transform': {'content': {'url': 'http://xxxxx', 'description': '小女孩在公园'}}}}
receive chunk:  type='end node stream' index=1 payload={'output': {'end_transform': {'content': {'url': 'http://xxxxx', 'description': '上学的小女孩'}}}}
receive chunk:  type='end node stream' index=2 payload={'output': {'end_transform': {'content': {'status': 'finished'}}}}
receive chunk:  type='end node stream' index=3 payload={'output': {'end_transform': {'status': 'finished'}}}
receive chunk:  type='end node stream' index=0 payload={'status': 'finished'}
result={'output': {'result': {'result': [{'url': 'http://xxxxx', 'description': '小女孩在公园'}, {'url': 'http://xxxxx', 'description': '上学的小女孩'}, {'status': 'finished'}]}}} state=<WorkflowExecutionState.COMPLETED: 'COMPLETED'>
```
## 继承WorkflowComponent

`ComputeExecutor`继承自`ComponentExecutable`，支持单次数学运算与多次数学的累加处理，通过`invoke`方法处理单次输入，执行指定类型的数学运算（加、减、乘、除），通过`stream`方法将输入的批量数据，分别进行指定的数学运算，每次的结果作为流式数据传递给下个组件，实现高效的数据处理与汇总。

```python
from typing import AsyncIterator

from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.runtime.base import ComponentExecutable, Input, Output
from openjiuwen.core.runtime.runtime import Runtime


class ComputeExecutor(ComponentExecutable):
    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        """ 处理单个输入，调用__calculate__来执行具体的数学运算，并将结果返回 """
        return {"result": self.__calculate__(data=inputs.get("data"))}

    async def stream(self, inputs: Input, runtime: Runtime, context: Context) -> AsyncIterator[Output]:
        datas = inputs.get("data")
        for data in datas:
            yield {"result": self.__calculate__(data=data)}

    @staticmethod
    def __calculate__(data):
        """ 根据输入指定的参数及运算符，执行具体的加、减、乘、除运算 """
        operator = data.get("op", None)
        data = data.get("data", None)
        a = data.get("a", 0)
        b = data.get("b", 0)
        if operator == "add":
            return a + b
        elif operator == "subtract":
            return a - b
        elif operator == "multiply":
            return a * b
        elif operator == "divide":
            return a / b if b != 0 else 0
        else:
            return None
```

`ComputeComponent`继承`WorkflowComponent`，是用于数学运算的组件，实现`to_executable`方法提供了实现计算逻辑的`ComputeExecutor`实例，实现`add_component`方法将`ComputeComponent`节点添加到工作流中。

```python
from openjiuwen.core.graph.base import Graph
from openjiuwen.core.graph.executable import Executable
from openjiuwen.core.component.base import WorkflowComponent


class ComputeComponent(WorkflowComponent):
    def add_component(self, graph: Graph, node_id: str, wait_for_all: bool = False) -> None:
        """ 将当前组件的ComputeExecutor添加到图中。 """
        graph.add_node(node_id, self.to_executable(), wait_for_all=wait_for_all)

    def to_executable(self) -> Executable:
        """ 将当前对象转换为ComputeExecutor实例返回 """
        return ComputeExecutor()

```


通过`workflow.add_workflow_comp`方法将自定义的`ComputeComponent`组件添加到图中（此时工作流会调用自定义的`ComputeComponent`组件的`add_component`方法，将组件自己增加到工作流中），设置组件id为`compute`，并指定输入schema为`{"data": "${last_component.result}"}`：

```python
from openjiuwen.core.workflow.base import Workflow

workflow = Workflow()
workflow.add_workflow_comp("compute", ComputeComponent(), inputs_schema={"data": "${last_component.result}"})
```

调用`workflow.invoke`方法执行工作流，首次执行工作流时，工作流内部会先进行`compile`，此时会调用到自定义`ComputeComponent`组件的`to_executable`方法生成`ComputeExecutor`的实例，后续工作流的执行都会调用`ComputeExecutor`实例的相关接口。

- 若`compute`组件前置节点`last_component`的输出为`"{data": {"op": "add", "data":{ "a":1, "b":2}}`，那么工作流会自动调用`ComputeExecutor`的`invoke`接口，输出为`{"result":3}`。
- 若`compute`的组件前置节点`last_component`的输出为：`{"data":[{"op": "add", "data":{ "a":1, "b":2}}, {"op": "multiply", "data":{ "a":1, "b":2}}, {"op": "add", "data":{ "a":2, "b":3}}]}`，那么工作流会自动调用到`ComputeExecutor`的`stream`接口，输出结果为3帧数据`{"result":3}`，`{"result":2}`，`{"result":5}`。

**完整代码**：

```python
import asyncio
from typing import AsyncIterator

from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.component.end_comp import End
from openjiuwen.core.component.start_comp import Start
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.graph.base import Graph
from openjiuwen.core.graph.executable import Output, Input, Executable
from openjiuwen.core.runtime.base import ComponentExecutable
from openjiuwen.core.runtime.runtime import Runtime
from openjiuwen.core.runtime.workflow import WorkflowRuntime
from openjiuwen.core.stream.base import BaseStreamMode
from openjiuwen.core.workflow.base import Workflow
from openjiuwen.core.workflow.workflow_config import ComponentAbility


class ComputeExecutor(ComponentExecutable):
    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        """ 处理单个输入，调用__calculate__来执行具体的数学运算，并将结果返回 """
        return {"result": self.__calculate__(data=inputs.get("data"))}

    async def stream(self, inputs: Input, runtime: Runtime, context: Context) -> AsyncIterator[Output]:
        datas = inputs.get("data")
        for data in datas:
            yield {"result": self.__calculate__(data=data)}

    @staticmethod
    def __calculate__(data):
        """ 根据输入指定的参数及运算符，执行具体的加、减、乘、除运算 """
        operator = data.get("op", None)
        data = data.get("data", None)
        a = data.get("a", 0)
        b = data.get("b", 0)
        if operator == "add":
            return a + b
        elif operator == "subtract":
            return a - b
        elif operator == "multiply":
            return a * b
        elif operator == "divide":
            return a / b if b != 0 else 0
        else:
            return None

class ComputeComponent(WorkflowComponent):
    def add_component(self, graph: Graph, node_id: str, wait_for_all: bool = False) -> None:
        """ 将当前组件的ComputeExecutor添加到图中。 """
        graph.add_node(node_id, self.to_executable(), wait_for_all=wait_for_all)

    def to_executable(self) -> Executable:
        """ 将当前对象转换为ComputeExecutor实例返回 """
        return ComputeExecutor()


async def run_invoke_workflow():
    workflow = Workflow()
    workflow.set_start_comp("start", Start(), inputs_schema={"data": "${user_input.data}"})
    workflow.add_workflow_comp("compute", ComputeComponent(), inputs_schema={"data": "${start.data}"})
    workflow.set_end_comp("end", End(), inputs_schema={"result": "${compute.result}"})
    workflow.add_connection("start", "compute")
    workflow.add_connection("compute", "end")
    print(await workflow.invoke(inputs={"user_input": {"data": {"op": "add", "data": {"a": 1, "b": 2}}}},
                                runtime=WorkflowRuntime()))
async def run_stream_workflow():
    workflow = Workflow()
    workflow.set_start_comp("start", Start(), inputs_schema={"data": "${user_input.data}"})
    workflow.add_workflow_comp("compute", ComputeComponent(), inputs_schema={"data": "${start.data}"}, comp_ability=[ComponentAbility.STREAM], wait_for_all=True)
    workflow.set_end_comp("end", End(), stream_inputs_schema={"result": "${compute.result}"}, response_mode="streaming")
    workflow.add_connection("start", "compute")
    workflow.add_stream_connection("compute", "end")
    async for chunk in workflow.stream(inputs={"user_input": {"data":[{"op": "add", "data":{ "a":1, "b":2}}, {"op": "multiply", "data":{ "a":1, "b":2}}, {"op": "add", "data":{ "a":2, "b":3}}]}},
                                       runtime=WorkflowRuntime(), stream_modes=[BaseStreamMode.OUTPUT]):
        print(chunk)


if __name__ == "__main__":
    asyncio.run(run_invoke_workflow())
    asyncio.run(run_stream_workflow())
```

执行结果：
```python
result={'output': {'result': 3}} state=<WorkflowExecutionState.COMPLETED: 'COMPLETED'>
type='end node stream' index=0 payload={'output': {'compute': {'result': 3}}}
type='end node stream' index=1 payload={'output': {'compute': {'result': 2}}}
type='end node stream' index=2 payload={'output': {'compute': {'result': 5}}}
```

# 定制组件分支

用户在组件的开发中，存在为组件定制配套分支的场景。例如openJiuwen内置意图识别组件`IntentDetectionComponent`，提供了`add_branch`接口，为意图识别的结果定制了相应的分支。

openJiuwen提供了三种为组件定制配套分支的方案：

- **连接BranchComponent**：构建工作流中，在自定义组件后连接分支组件`BranchComponent`，并通过分支组件的`add_branch`接口，将定制分支配置到分支组件中。
- **条件连接**：构建工作流中，在自定义组件后添加条件分支，为条件分支定制配套的`BranchRouter`。
- **组件集成BranchRouter**：将`BranchRouter`集成在自定义组件中，并暴露出`add_branch`接口，例如openJiuwen内置意图识别组件`IntentDetectionComponent`的实现。

首先，开发用于旅游意图识别的组件`CustomComponent`，模拟意图识别筛选过程，意图种类有“出行”和“餐饮”两种，具体实现如下：

```python
import random

from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.runtime.base import ComponentExecutable, Input, Output
from openjiuwen.core.runtime.runtime import Runtime

class CustomComponent(WorkflowComponent, ComponentExecutable):
    def __init__(self):
        super().__init__()
        self.intent = ['餐饮', '出行']

    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        # 模拟意图识别筛选过程
        return {'result': self.intent[random.randint(0, len(self.intent))]}
```

以下以为自定义组件`CustomComponent`的两种意图定制不同的分支为例，介绍三种方案实现的具体方式。

- 若`result == '餐饮'`，分支匹配到用于处理餐饮意图的工作流处理组件"A"中。
- 若`result == '出行'`，分支匹配到用于处理出行意图的工作流处理组件"B"中。

## 连接BranchComponent

在构建工作流式，在自定义组件后连接`BranchComponent`，并定制自定义的分支。工作流的结构如下图所示。

<div align="center">
  <img src="../images/my_component.png" alt="CustomComponent" width="50%">
</div>

构建工作流代码如下：

```python
from openjiuwen.core.component.branch_comp import BranchComponent
from openjiuwen.core.component.workflow_comp import SubWorkflowComponent
from openjiuwen.core.workflow.base import Workflow

workflow = Workflow()
workflowA = Workflow()
workflowB = Workflow()
# 增加自定义节点"intent"，用于处理餐饮
workflow.add_workflow_comp("custom", CustomComponent())
workflow.add_workflow_comp("A", SubWorkflowComponent(workflowA))
workflow.add_workflow_comp("B", SubWorkflowComponent(workflowB))

# 增加分支节点"branch"，并创建分支
branch_comp = BranchComponent()
branch_comp.add_branch("${custom.result} == '出行'", ["A"])
branch_comp.add_branch("${custom.result} == '餐饮'", ["B"])

# 将branch组件和具体匹配的分支目标节点加到工作流中
workflow.add_workflow_comp("branch", branch_comp)

# 连接自定义节点和分支节点
workflow.add_connection("custom", "branch")
```

## 条件连接

为自定义节点添加条件边，并提供BranchRouter。实现方案案例如下：

```python
import random

from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.component.branch_router import BranchRouter
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.runtime.base import ComponentExecutable, Input, Output
from openjiuwen.core.runtime.runtime import Runtime
from openjiuwen.core.component.workflow_comp import SubWorkflowComponent
from openjiuwen.core.workflow.base import Workflow

class CustomComponent(WorkflowComponent, ComponentExecutable):
    def __init__(self):
        super().__init__()
        self.intent = ['餐饮', '出行']

    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        # 模拟意图识别筛选过程
        return {'result': self.intent[random.randint(0, len(self.intent))]}

workflow = Workflow()
workflowA = Workflow()
workflowB = Workflow()
workflow.add_workflow_comp("custom", CustomComponent())
workflow.add_workflow_comp("A", SubWorkflowComponent(workflowA))
workflow.add_workflow_comp("B", SubWorkflowComponent(workflowB))

branch_router = BranchRouter()
branch_router.add_branch("${custom.result} == '出行'", ["A"], "id1")
branch_router.add_branch("${custom.result} == '餐饮'", ["B"], "id2")

# 增加条件边，并指定router为branch_router
workflow.add_conditional_connection("custom", router=branch_router)
```

## 组件集成BranchRouter

将`BranchRouter`集成在自定义组件中，并暴露出`add_branch`接口。该方案需要重新实现`add_component`接口，并将rounter添加到graph中。

自定义组件重新实现：

```python
import random
from typing import Callable, Union

from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.component.branch_router import BranchRouter
from openjiuwen.core.component.condition.condition import Condition
from openjiuwen.core.component.workflow_comp import SubWorkflowComponent
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.graph.base import Graph
from openjiuwen.core.runtime.base import ComponentExecutable, Input, Output
from openjiuwen.core.runtime.runtime import Runtime
from openjiuwen.core.workflow.base import Workflow


class CustomComponent(WorkflowComponent, ComponentExecutable):
    def __init__(self):
        super().__init__()
        self.intent = ["餐饮", "出行"]
        # Use an actual router instance so branches can be registered and evaluated.
        self._router = BranchRouter()

    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        # 模拟意图识别筛选过程
        self._router.set_runtime(runtime)
        return {"result": random.choice(self.intent)}

    def to_executable(self) -> ComponentExecutable:
        return self

    def add_component(self, graph: Graph, node_id: str, wait_for_all: bool = False) -> None:
        graph.add_node(node_id, self.to_executable(), wait_for_all=wait_for_all)
        graph.add_conditional_edges(node_id, self._router)

    def add_branch(
        self,
        condition: Union[str, Callable[[], bool], Condition],
        target: list[str],
        branch_id: str | None = None,
    ) -> None:
        self._router.add_branch(condition, target, branch_id=branch_id)
```

工作流构建构成改为：

```python
# 示例：为不同意图配置分支并装配到工作流
workflow = Workflow()
workflowA = Workflow()
workflowB = Workflow()

custom = CustomComponent()
custom.add_branch("${custom.result} == '出行'", ["A"], "branch_id1")
custom.add_branch("${custom.result} == '餐饮'", ["B"], "branch_id2")
workflow.add_workflow_comp("custom", custom)
workflow.add_workflow_comp("A", SubWorkflowComponent(workflowA))
workflow.add_workflow_comp("B", SubWorkflowComponent(workflowB))
```

完整示例：
```python
import random
from typing import Callable, Union

from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.component.branch_router import BranchRouter
from openjiuwen.core.component.condition.condition import Condition
from openjiuwen.core.component.workflow_comp import SubWorkflowComponent
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.graph.base import Graph
from openjiuwen.core.runtime.base import ComponentExecutable, Input, Output
from openjiuwen.core.runtime.runtime import Runtime
from openjiuwen.core.workflow.base import Workflow


class CustomComponent(WorkflowComponent, ComponentExecutable):
    def __init__(self):
        super().__init__()
        self.intent = ["餐饮", "出行"]
        # Use an actual router instance so branches can be registered and evaluated.
        self._router = BranchRouter()

    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        # 模拟意图识别筛选过程
        self._router.set_runtime(runtime)
        return {"result": random.choice(self.intent)}

    def to_executable(self) -> ComponentExecutable:
        return self

    def add_component(self, graph: Graph, node_id: str, wait_for_all: bool = False) -> None:
        graph.add_node(node_id, self.to_executable(), wait_for_all=wait_for_all)
        graph.add_conditional_edges(node_id, self._router)

    def add_branch(
        self,
        condition: Union[str, Callable[[], bool], Condition],
        target: list[str],
        branch_id: str | None = None,
    ) -> None:
        self._router.add_branch(condition, target, branch_id=branch_id)


# 示例：为不同意图配置分支并装配到工作流
workflow = Workflow()
workflowA = Workflow()
workflowB = Workflow()

custom = CustomComponent()
custom.add_branch("${custom.result} == '出行'", ["A"], "branch_id1")
custom.add_branch("${custom.result} == '餐饮'", ["B"], "branch_id2")
workflow.add_workflow_comp("custom", custom)
workflow.add_workflow_comp("A", SubWorkflowComponent(workflowA))
workflow.add_workflow_comp("B", SubWorkflowComponent(workflowB))
```