openJiuwen支持工作流单组件或者多组件同时中断恢复。中断恢复包含两种场景：

- **中断交互**：工作流组件执行过程中，需要与用户交互获取更多用户信息时，需要中断当前工作流的执行，等用户交互输入后，恢复工作流的执行；
- **异常中断**：当工作流组件在执行过程中出现异常报错，需要工作流保存现场，重新执行工作流时会从上次出现异常的组件继续执行。

# 中断交互

openJiuwen支持两种中断交互模式：单组件中断和多组件中断。这两种模式分别适用于不同复杂度的业务场景：

- 单组件中断：适用于组件独立交互场景，如单一确认操作。
- 多组件中断：适用于复杂协同场景，如多类型信息同步补全。

## 单组件中断

单个组件中断等待用户输入，用户输入无需区分组件，中断组件获取到用户输入后即可继续执行。

首先定义一个带交互的组件，组件实现了`invoke`方法，在`invoke`方法提取了用户输入的命令`cmd`，调用`Runtime`的`interact`接口传递问题给用户，询问用户是否要执行命令，并等待用户的回答，获取到用户回答后将用户回答作为`invoke`方法的返回内容。

```python
import asyncio
import uuid

from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.component.end_comp import End
from openjiuwen.core.component.start_comp import Start
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.runtime.base import ComponentExecutable, Input, Output
from openjiuwen.core.runtime.interaction.interactive_input import InteractiveInput
from openjiuwen.core.runtime.runtime import Runtime
from openjiuwen.core.runtime.workflow import WorkflowRuntime
from openjiuwen.core.workflow.base import Workflow

# 带交互的组件
class InteractiveNode(ComponentExecutable, WorkflowComponent):
    def __init__(self):
        super().__init__()

    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        cmd = inputs.get("cmd")
        # 向用户提问, 等待用户回答
        result = await runtime.interact(f"Do you want to execute the command '{cmd}'?")
        return {"confirm_result": result}
```

构建一个工作流，工作流由开始组件、交互组件、结束组件组成，组件按顺序执行。

```python
flow = Workflow()
flow.set_start_comp("start", Start({}), inputs_schema={"command": "${cmd}"})
flow.add_workflow_comp("interactive_node", InteractiveNode(),
                       inputs_schema={"cmd": "${start.command}"},
                       outputs_schema={"result": "${confirm_result}"})
flow.set_end_comp("end", End(),
                  inputs_schema={"result": "${interactive_node.result}"})
flow.add_connection("start", "interactive_node")
flow.add_connection("interactive_node", "end")
```

然后执行工作流，执行工作流前需要生成一个`session_id`用于创建`WorkflowRuntime`，执行完工作流后打印工作流的输出。

```python
# 生成会话id
session_id = uuid.uuid4().hex
    
# 用户第一次输入
output = asyncio.run(flow.invoke({"cmd": "delete all files"}, WorkflowRuntime(session_id=session_id)))

print(output)
```

运行上述代码后可看到：

```python
result=[OutputSchema(type='__interaction__', index=0, payload=InteractionOutput(id='interactive_node', value="Do you want to execute the command 'delete all files'?"))] state=<WorkflowExecutionState.INPUT_REQUIRED: 'INPUT_REQUIRED'>
```

其中`output`为工作流输出，详细见[工作流输出介绍](./流式输出.md#工作流流式输出)；`result`为列表，列表中每个元素为流式输出的元素，详细见[流式输出介绍](./流式输出.md)；`type`为`__interaction__`代表消息类型为中断消息，`index`为`0`代表组件的第一个中断，`payload`中的内容为中断输出，详细见[中断输出介绍](#中断交互)。

最后再次执行工作流，再次执行工作流前需要构造交互输入，由于只有一个中断交互组件，所以构造交互输入时不需要指定交互组件`id`。将交互输入作为工作流`invoke`方法的输入传入，再次执行工作流时使用的`WorkflowRuntime`需要用相同的`session_id`构造，才能保证恢复中断。执行完工作流后打印工作流的输出。

```python
# 包装用户回答
user_input = InteractiveInput("Yes")
# 将用户回答传入工作流, 会话id要相同
output = asyncio.run(flow.invoke(user_input, WorkflowRuntime(session_id=session_id)))

print(output.result)
```

运行上述代码后可看到：

```python
{'output': {'result': 'Yes'}}
```

**完整代码：**

```python
import asyncio
import uuid

from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.component.end_comp import End
from openjiuwen.core.component.start_comp import Start
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.runtime.base import ComponentExecutable, Input, Output
from openjiuwen.core.runtime.interaction.interactive_input import InteractiveInput
from openjiuwen.core.runtime.runtime import Runtime
from openjiuwen.core.runtime.workflow import WorkflowRuntime
from openjiuwen.core.workflow.base import Workflow


class InteractiveNode(ComponentExecutable, WorkflowComponent):
    def __init__(self):
        super().__init__()

    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        cmd = inputs.get("cmd")
        # 向用户提问, 等待用户回答
        result = await runtime.interact(f"Do you want to execute the command '{cmd}'?")
        return {"confirm_result": result}
    
    
flow = Workflow()
flow.set_start_comp("start", Start({}), inputs_schema={"command": "${cmd}"})
flow.add_workflow_comp("interactive_node", InteractiveNode(),
                       inputs_schema={"cmd": "${start.command}"},
                       outputs_schema={"result": "${confirm_result}"})
flow.set_end_comp("end", End(),
                  inputs_schema={"result": "${interactive_node.result}"})
flow.add_connection("start", "interactive_node")
flow.add_connection("interactive_node", "end")

# 生成会话id
session_id = uuid.uuid4().hex

# 用户第一次输入
output = asyncio.run(flow.invoke({"cmd": "delete all files"}, WorkflowRuntime(session_id=session_id)))

print(output)


# 包装用户回答
user_input = InteractiveInput("Yes")
# 将用户回答传入工作流, 会话id要相同
output = asyncio.run(flow.invoke(user_input, WorkflowRuntime(session_id=session_id)))

print(output.result)
```

输出结果

```python
result=[OutputSchema(type='__interaction__', index=0, payload=InteractionOutput(id='interactive_node', value="Do you want to execute the command 'delete all files'?"))] state=<WorkflowExecutionState.INPUT_REQUIRED: 'INPUT_REQUIRED'>
{'output': {'result': 'Yes'}}
```

## 多组件中断

多个组件同时中断等待用户输入，用户需要为每个中断组件分别准备输入，所有中断组件都获取到用户输入后，工作流即可继续执行。

首先定义第一个带交互的组件，组件实现了`invoke`方法，在`invoke`方法提取了用户输入的命令`cmd`，调用`Runtime`的`interact`接口传递问题给用户，询问用户是否要执行命令，并等待用户的回答，获取到用户回答后将用户回答作为`invoke`方法的返回内容。

```python
import asyncio
import uuid

from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.component.end_comp import End
from openjiuwen.core.component.start_comp import Start
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.runtime.base import ComponentExecutable, Input, Output
from openjiuwen.core.runtime.interaction.interactive_input import InteractiveInput
from openjiuwen.core.runtime.runtime import Runtime
from openjiuwen.core.runtime.workflow import WorkflowRuntime
from openjiuwen.core.workflow.base import Workflow

# 第一个带交互的组件
class InteractiveNode1(ComponentExecutable, WorkflowComponent):
    def __init__(self):
        super().__init__()

    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        cmd = inputs.get("cmd")
        # 向用户提问, 等待用户回答
        result = await runtime.interact(f"Do you want to execute the command '{cmd}'?")
        return {"confirm_result": result}
```

接着定义第二个带交互的组件，组件实现了`invoke`方法，在`invoke`方法提取了用户输入的命令`cmd`，调用`Runtime`的`interact`接口传递问题给用户，询问用户是否要执行命令，并等待用户的回答，获取到用户回答后将用户回答作为`invoke`方法的返回内容。

```python
# 第二个带交互的组件
class InteractiveNode2(ComponentExecutable, WorkflowComponent):
    def __init__(self):
        super().__init__()

    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        cmd = inputs.get("cmd")
        # 向用户提问, 等待用户回答
        result = await runtime.interact(f"Do you want to execute the command '{cmd}'?")
        return {"confirm_result": result}
```

构建一个工作流，工作流由开始组件、两个交互组件和结束组件组成，其中两个交互组件在工作流中并发执行。

```python
flow = Workflow()
flow.set_start_comp("start", Start({}), inputs_schema={"command1": "${cmd1}", "command2": "${cmd2}"})
flow.add_workflow_comp("interactive_node1", InteractiveNode1(),
                       inputs_schema={"cmd": "${start.command1}"},
                       outputs_schema={"result": "${confirm_result}"})
flow.add_workflow_comp("interactive_node2", InteractiveNode2(),
                   inputs_schema={"cmd": "${start.command2}"},
                   outputs_schema={"result": "${confirm_result}"})
flow.set_end_comp("end", End(),
                  inputs_schema={"result1": "${interactive_node1.result}", "result2": "${interactive_node2.result}"})
flow.add_connection("start", "interactive_node1")
flow.add_connection("start", "interactive_node2")
flow.add_connection("interactive_node1", "end")
flow.add_connection("interactive_node2", "end")
```

指定`session_id`执行工作流，执行完工作流后打印工作流的输出。由于有两个并发执行的交互组件，所以有两个交互输出。

```python
# 生成会话id
session_id = uuid.uuid4().hex
    
# 用户第一次输入
output = asyncio.run(flow.invoke({"cmd1": "delete all files", "cmd2": "kill all processes"}, WorkflowRuntime(session_id=session_id)))

print(output)
```

运行上述代码后可看到：

```python
result=[OutputSchema(type='__interaction__', index=0, payload=InteractionOutput(id='interactive_node1', value="Do you want to execute the command 'delete all files'?")), OutputSchema(type='__interaction__', index=0, payload=InteractionOutput(id='interactive_node2', value="Do you want to execute the command 'kill all processes'?"))] state=<WorkflowExecutionState.INPUT_REQUIRED: 'INPUT_REQUIRED'>
```

其中`output`为工作流输出，详细见[工作流输出介绍](./流式输出.md#工作流流式输出)；`result`为列表，列表中每个元素为流式输出的元素，详细见[流式输出介绍](./流式输出.md)；`type`为`__interaction__`代表消息类型为中断消息，`index`为`0`代表每个组件的第一个中断，`payload`中的内容为中断输出，详细见[中断输出介绍](#中断交互)。

最后再次执行工作流，再次执行工作流前需要构造交互输入，由于有两个同时执行的交互组件，所以构造交互输入时需要指定交互组件的`id`。将交互输入作为工作流`invoke`方法的输入传入，再次执行工作流时使用的`WorkflowRuntime`需要用相同的`session_id`构造，才能保证中断恢复。执行完工作流后打印工作流的输出。

```python
# 获取中断组件ID
node_id1 = output.result[0].payload.id
node_id2 = output.result[1].payload.id
# 包装用户回答, 为不同的中断组件提供不同的回答
user_input = InteractiveInput()
user_input.update(node_id1, "Yes")
user_input.update(node_id2, "No")
# 将用户回答传入工作流, 会话id要相同
output = asyncio.run(flow.invoke(user_input, WorkflowRuntime(session_id=session_id)))

print(output.result)
```

运行上述代码后可看到：

```python
{'output': {'result1': 'Yes', 'result2': 'No'}}
```

**完整代码：**

```python
import asyncio
import uuid

from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.component.end_comp import End
from openjiuwen.core.component.start_comp import Start
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.runtime.base import ComponentExecutable, Input, Output
from openjiuwen.core.runtime.interaction.interactive_input import InteractiveInput
from openjiuwen.core.runtime.runtime import Runtime
from openjiuwen.core.runtime.workflow import WorkflowRuntime
from openjiuwen.core.workflow.base import Workflow

# 第一个带交互的组件
class InteractiveNode1(ComponentExecutable, WorkflowComponent):
    def __init__(self):
        super().__init__()

    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        cmd = inputs.get("cmd")
        # 向用户提问, 等待用户回答
        result = await runtime.interact(f"Do you want to execute the command '{cmd}'?")
        return {"confirm_result": result}
    
# 第二个带交互的组件
class InteractiveNode2(ComponentExecutable, WorkflowComponent):
    def __init__(self):
        super().__init__()

    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        cmd = inputs.get("cmd")
        # 向用户提问, 等待用户回答
        result = await runtime.interact(f"Do you want to execute the command '{cmd}'?")
        return {"confirm_result": result}
    
flow = Workflow()
flow.set_start_comp("start", Start({}), inputs_schema={"command1": "${cmd1}", "command2": "${cmd2}"})
flow.add_workflow_comp("interactive_node1", InteractiveNode1(),
                       inputs_schema={"cmd": "${start.command1}"},
                       outputs_schema={"result": "${confirm_result}"})
flow.add_workflow_comp("interactive_node2", InteractiveNode2(),
                   inputs_schema={"cmd": "${start.command2}"},
                   outputs_schema={"result": "${confirm_result}"})
flow.set_end_comp("end", End(),
                  inputs_schema={"result1": "${interactive_node1.result}", "result2": "${interactive_node2.result}"})
flow.add_connection("start", "interactive_node1")
flow.add_connection("start", "interactive_node2")
flow.add_connection("interactive_node1", "end")
flow.add_connection("interactive_node2", "end")

# 生成会话id
session_id = uuid.uuid4().hex

# 用户第一次输入
output = asyncio.run(
    flow.invoke({"cmd1": "delete all files", "cmd2": "kill all processes"}, WorkflowRuntime(session_id=session_id)))

print(output)

# 获取中断组件ID
node_id1 = output.result[0].payload.id
node_id2 = output.result[1].payload.id
# 包装用户回答, 为不同的中断组件提供不同的回答
user_input = InteractiveInput()
user_input.update(node_id1, "Yes")
user_input.update(node_id2, "No")
# 将用户回答传入工作流, 会话id要相同
output = asyncio.run(flow.invoke(user_input, WorkflowRuntime(session_id=session_id)))

print(output.result)

```

输出结果：
```python
result=[OutputSchema(type='__interaction__', index=0, payload=InteractionOutput(id='interactive_node1', value="Do you want to execute the command 'delete all files'?")), OutputSchema(type='__interaction__', index=0, payload=InteractionOutput(id='interactive_node2', value="Do you want to execute the command 'kill all processes'?"))] state=<WorkflowExecutionState.INPUT_REQUIRED: 'INPUT_REQUIRED'>
{'output': {'result1': 'Yes', 'result2': 'No'}}
```

# 异常中断

异常中断恢复是指工作流在执行过程中遇到一些非预期的异常情况，工作流也会保存现场，重新执行工作流时会从上次出现异常的组件继续执行。

以网络连接超时异常为例，介绍中断恢复过程。可看到首次进入时抛出连接超时异常，第二次进入时正常执行。

首先定义一个正常组件，该组件实现了方法`invoke`，该方法打印`invoke normal node`并返回空字典。

```python
import asyncio
import uuid

from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.component.end_comp import End
from openjiuwen.core.component.start_comp import Start
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.runtime.base import ComponentExecutable, Input, Output
from openjiuwen.core.runtime.interaction.interactive_input import InteractiveInput
from openjiuwen.core.runtime.runtime import Runtime
from openjiuwen.core.runtime.workflow import WorkflowRuntime
from openjiuwen.core.workflow.base import Workflow

# 正常的组件
class NormalNode(ComponentExecutable, WorkflowComponent):
    def __init__(self):
        super().__init__()

    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        print("invoke normal node")
        return {}
```

接着定义一个会抛异常的组件，同样实现`invoke`方法，该方法在组件被第一次调用时抛出异常，第二次执行时正常返回空字典。

```python
# 会抛异常的组件
class AbnormalNode(ComponentExecutable, WorkflowComponent):
    def __init__(self):
        super().__init__()
        self.first_time_invoke = True

    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        # 模拟第一次调用时出现网络超时
        if self.first_time_invoke:
            self.first_time_invoke = False
            raise Exception("connection timeout")
        return {}
```

构建一个工作流，工作流由开始组件、正常组件、异常组件、结束组件组成，组件按顺序执行。

```python
flow = Workflow()
flow.set_start_comp("start", Start({}), inputs_schema={"query": "${query}"})
flow.add_workflow_comp("normal_node", NormalNode())
flow.add_workflow_comp("abnormal_node", AbnormalNode())
flow.set_end_comp("end", End(),
                  inputs_schema={"result": "${start.query}"})
flow.add_connection("start", "normal_node")
flow.add_connection("normal_node", "abnormal_node")
flow.add_connection("abnormal_node", "end")
```

执行工作流，执行工作流前需要生成一个`session_id`用于创建`WorkflowRuntime`，由于存在异常组件，所以需要捕获工作流执行的异常，并打印异常信息。

```python
# 生成会话id
session_id = uuid.uuid4().hex
    
# 用户第一次输入
try:
    asyncio.run(flow.invoke({"query": "hello"}, WorkflowRuntime(session_id=session_id)))
except Exception as e:
    # 输出connection timeout
    print(e)
```

运行上述代码后可看到：

```python
invoke normal node
connection timeout
```

最后再次执行工作流，再次执行工作流前需要构造交互输入，异常场景只需要构造空的交互输入就行。将交互输入作为工作流`invoke`方法的输入传入，再次执行工作流时使用的`WorkflowRuntime`需要用相同的`session_id`构造，才能保证中断恢复。执行完工作流后打印工作流的输出。

```python
# 用户重试，使用相同的会话id，并输入空的 InteractiveInput
user_input = InteractiveInput()
output = asyncio.run(flow.invoke(user_input, WorkflowRuntime(session_id=session_id)))
# 这里打印出 hello
print(output.result.get("output").get("result"))
```

运行上述代码后可看到：

```python
hello
```

第二次执行不再打印`invoke nomal node`，说明第二次执行时是从正常组件之后开始执行的。

**完整代码：**

```python
import asyncio
import uuid

from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.component.end_comp import End
from openjiuwen.core.component.start_comp import Start
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.runtime.base import ComponentExecutable, Input, Output
from openjiuwen.core.runtime.interaction.interactive_input import InteractiveInput
from openjiuwen.core.runtime.runtime import Runtime
from openjiuwen.core.runtime.workflow import WorkflowRuntime
from openjiuwen.core.workflow.base import Workflow


# 正常的组件
class NormalNode(ComponentExecutable, WorkflowComponent):
    def __init__(self):
        super().__init__()

    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        print("invoke normal node")
        return {}
    
    
# 会抛异常的组件
class AbnormalNode(ComponentExecutable, WorkflowComponent):
    def __init__(self):
        super().__init__()
        self.first_time_invoke = True

    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        # 模拟第一次调用时出现网络超时
        if self.first_time_invoke:
            self.first_time_invoke = False
            raise Exception("connection timeout")
        return {}
    
flow = Workflow()
flow.set_start_comp("start", Start({}), inputs_schema={"query": "${query}"})
flow.add_workflow_comp("normal_node", NormalNode())
flow.add_workflow_comp("abnormal_node", AbnormalNode())
flow.set_end_comp("end", End(),
                  inputs_schema={"result": "${start.query}"})
flow.add_connection("start", "normal_node")
flow.add_connection("normal_node", "abnormal_node")
flow.add_connection("abnormal_node", "end")

# 生成会话id
session_id = uuid.uuid4().hex

# 用户第一次输入
try:
    asyncio.run(flow.invoke({"query": "hello"}, WorkflowRuntime(session_id=session_id)))
except Exception as e:
    # 输出connection timeout
    print(e)
    
    
# 用户重试，使用相同的会话id，并输入空的 InteractiveInput
user_input = InteractiveInput()
output = asyncio.run(flow.invoke(user_input, WorkflowRuntime(session_id=session_id)))
# 这里打印出 hello
print(output.result.get("output").get("result"))
```
输出结果

```python
invoke normal node
[100005] component [abnormal_node] encountered an exception while executing ability [invoke], error detail: connection timeout
hello
```
