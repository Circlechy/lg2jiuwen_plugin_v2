openJiuwen的`Runtime`提供了资源管理的能力，方便用户获取、使用或者释放不同资源的实例，避免了反复创建实例的资源浪费，也提升了创建的性能。当前，`Runtime`提供了以下四种资源的管理：

- **工作流的实例**：即`Workflow`实例，是对组件执行逻辑的封装。
- **大模型的实例**：即`BaseModelClient`实例，包含具体模型配置、API密钥及调用参数的运行时对象，用于实际发起推理请求并与外部系统交互。
- **Prompt模板的实例**：即`Template`实例，由模板名和提示词组成的运行时对象。
- **工具的实例**：即`Tool`实例，基于预定义模板创建的可执行组件，用于完成特定任务并返回结构化的结果。

# 工作流实例管理

`Runtime`提供了`Workflow`实例的添加、查询、删除、以及批量添加的能力。

通过`add_workflow`接口可添加一个工作流实例，添加的时候需要指定工作流的唯一名称，后续可通过`get_workflow`接口使用指定的名称查询已添加的工作流。

```python
# 注意：此代码片段依赖于完整的 runtime 初始化和上下文配置，不能单独运行，请参考完整代码示例。
from openjiuwen.core.workflow.workflow_config import WorkflowConfig, WorkflowMetadata

workflow1 = _create_workflow(workflow_config=WorkflowConfig(metadata=WorkflowMetadata(id="1", version="1")))
runtime.add_workflow("1_1", workflow1)
workflow_1 = await runtime.get_workflow("1_1")
metadata_1 = workflow_1.config().metadata
print(metadata_1)
```

运行结果：

```python
name='' id='1' version='1' description=''
```

通过`add_workflows`接口可批量添加工作流实例，每个工作流实例都需要指定唯一名称，后续可通过`get_workflow`接口进行查询。

```python
# 注意：此代码片段依赖于完整的 runtime 初始化和上下文配置，不能单独运行，请参考完整代码示例。
from openjiuwen.core.workflow.workflow_config import WorkflowConfig, WorkflowMetadata

workflow2 = _create_workflow(workflow_config=WorkflowConfig(metadata=WorkflowMetadata(id="2", version="2")))
workflow3 = _create_workflow(workflow_config=WorkflowConfig(metadata=WorkflowMetadata(id="3", version="3")))
runtime.add_workflows([("2_2", workflow2), ("3_3", workflow3)])

workflow_2 = await runtime.get_workflow("2_2")
metadata_2 = workflow_2.config().metadata
workflow_3 = await runtime.get_workflow("3_3")
metadata_3 = workflow_3.config().metadata
print(metadata_2)
print(metadata_3)
```

返回结果：

```python
name='' id='2' version='2' description=''
name='' id='3' version='3' description=''
```

通过`remove_workflow`接口可删除已经添加的工作流实例，根据指定的工作流名称进行删除。

```python
# 注意：此代码片段依赖于完整的 runtime 初始化和上下文配置，不能单独运行，请参考完整代码示例。
runtime.remove_workflow("2_2")
workflow_2 = await runtime.get_workflow("2_2")
print(workflow_2)
```

运行输出：

```python
None
```

完整代码：

```python
import asyncio

from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.component.end_comp import End
from openjiuwen.core.component.start_comp import Start
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.runtime.base import ComponentExecutable, Input, Output
from openjiuwen.core.runtime.runtime import Runtime
from openjiuwen.core.runtime.workflow import WorkflowRuntime
from openjiuwen.core.workflow.base import Workflow
from openjiuwen.core.workflow.workflow_config import WorkflowConfig, WorkflowMetadata


class CustomComponent(WorkflowComponent, ComponentExecutable):
    def __init__(self, workflow_id):
        super().__init__()
        self._workflow_id = workflow_id

    def _create_workflow(self, workflow_config):
        workflow = Workflow(workflow_config)
        workflow.set_start_comp("start", Start())
        workflow.set_end_comp("end", End())
        workflow.add_connection("start", "end")
        return workflow

    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        # 添加1个workflow
        workflow1 = self._create_workflow(workflow_config=WorkflowConfig(metadata=WorkflowMetadata(id="1", version="1")))
        runtime.add_workflow("1_1", workflow1)
        workflow_1 = await runtime.get_workflow("1_1")
        metadata_1 = workflow_1.config().metadata
        print(metadata_1)

        # 批量添加workflow
        workflow2 = self._create_workflow(workflow_config=WorkflowConfig(metadata=WorkflowMetadata(id="2", version="2")))
        workflow3 = self._create_workflow(workflow_config=WorkflowConfig(metadata=WorkflowMetadata(id="3", version="3")))
        runtime.add_workflows([("2_2", workflow2), ("3_3", workflow3)])

        workflow_2 = await runtime.get_workflow("2_2")
        metadata_2 = workflow_2.config().metadata
        workflow_3 = await runtime.get_workflow("3_3")
        metadata_3 = workflow_3.config().metadata
        print(metadata_2)
        print(metadata_3)

        runtime.remove_workflow("2_2")
        workflow_2 = await runtime.get_workflow("2_2")
        print(workflow_2)

flow = Workflow()
flow.set_start_comp("start", Start())
flow.add_workflow_comp("custom", CustomComponent("custom"))
flow.set_end_comp("end", End())
flow.add_connection("start", "custom")
flow.add_connection("custom", "end")



if __name__ == "__main__":
    asyncio.run(flow.invoke(inputs={}, runtime=WorkflowRuntime()))
```

# Prompt模板实例管理

`Runtime`提供了提示词模板的添加、查询、删除、批量添加的能力。

通过`add_prompt`接口可添加一个`Prompt`模板实例，添加的时候需要指定模板的唯一名称，后续可通过`get_prompt`接口使用指定的名称查询已添加的模板。

```python
from openjiuwen.core.agent.agent import AgentRuntime
from openjiuwen.core.utils.prompt.template.template import Template

user_prompt = """
    {{user_prompt}}

    当前可供选择的功能分类如下：
    {{category_info}}

    用户与助手的对话历史：
    {{chat_history}}

    当前输入：
    {{input}}

    请根据当前输入和对话历史分析并输出最适合的功能分类。输出格式为 JSON：
    {"class": "分类xx"}
    如果没有合适的分类，请输出 {{default_class}}。
    """
intent_detection_template=Template(name="default",content=[{"role": "user", "content": user_prompt}])
runtime = AgentRuntime()
runtime.add_prompt("default_template", intent_detection_template)

print(runtime.get_prompt("default_template").name)
```

运行输出：

```python
default
```

`Runtime`也提供了批量添加的能力，例如：
通过`add_prompts`接口批量添加`Prompt`模板实例，每个模板实例都需要指定唯一名称，后续可通过`get_prompt`接口进行查询。

```python
from openjiuwen.core.utils.prompt.template.template import Template

intent_detection_template_1 = Template(name="default_1", content=[{"role": "user", "content": "{{user_prompt}}"}])
question_template = Template(name="ask", content=[{"role": "user", "content": "{{chat_history}}"}])
runtime.add_prompts([("default_template", intent_detection_template_1), ("question_template", question_template)])

print(runtime.get_prompt('default_template').name)
print(runtime.get_prompt('question_template').name)
```

输出：

```python
default_1
ask
```

通过`remove_prompt`接口可删除已经添加的`Prompt`模板实例，根据模板名称进行删除。

```python
runtime.remove_prompt("default_template")
print(runtime.get_prompt("default_template"))
```

运行结果：

```python
None
```

完整代码：

```python
import asyncio

from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.component.end_comp import End
from openjiuwen.core.component.start_comp import Start
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.runtime.base import ComponentExecutable, Input, Output
from openjiuwen.core.runtime.runtime import Runtime
from openjiuwen.core.runtime.workflow import WorkflowRuntime
from openjiuwen.core.utils.prompt.template.template import Template
from openjiuwen.core.workflow.base import Workflow


class CustomComponent(WorkflowComponent, ComponentExecutable):
    def __init__(self, workflow_id):
        super().__init__()
        self._workflow_id = workflow_id

    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        user_prompt = """
            {{user_prompt}}

            当前可供选择的功能分类如下：
            {{category_info}}

            用户与助手的对话历史：
            {{chat_history}}

            当前输入：
            {{input}}

            请根据当前输入和对话历史分析并输出最适合的功能分类。输出格式为 JSON：
            {"class": "分类xx"}
            如果没有合适的分类，请输出 {{default_class}}。
            """
        intent_detection_template = Template(name="default", content=[{"role": "user", "content": user_prompt}])
        runtime.add_prompt("default_template", intent_detection_template)

        print(runtime.get_prompt("default_template").name)

        intent_detection_template_1 = Template(name="default_1", content=[{"role": "user", "content": "{{user_prompt}}"}])
        question_template = Template(name="ask", content=[{"role": "user", "content": "{{chat_history}}"}])
        runtime.add_prompts([("default_template", intent_detection_template_1), ("question_template", question_template)])

        print(runtime.get_prompt('default_template').name)
        print(runtime.get_prompt('question_template').name)

        runtime.remove_prompt("default_template")
        print(runtime.get_prompt("default_template"))

flow = Workflow()
flow.set_start_comp("start", Start())
flow.add_workflow_comp("custom", CustomComponent("custom"))
flow.set_end_comp("end", End())
flow.add_connection("start", "custom")
flow.add_connection("custom", "end")


if __name__ == "__main__":
    asyncio.run(flow.invoke(inputs={}, runtime=WorkflowRuntime()))
```

# 大模型实例管理

`Runtime`提供了大模型实例的添加、查询、删除、批量添加的能力。

通过`add_model`接口可添加一个大模型实例，添加的时候需要指定实例的唯一名称，后续可通过`get_model`接口使用指定的名称查询已添加的实例。

```python
# 注意：此代码片段依赖于完整的 runtime 初始化和上下文配置，不能单独运行，请参考完整代码示例。
model = _get_model(10)
runtime.add_model("model", model)
saved_model = runtime.get_model("model")
print(f"保存模型: {type(saved_model).__name__}")
```

输出：

```python
保存模型: Siliconflow
```

通过`add_models`接口可批量添加大模型实例，每个大模型实例都需要指定唯一名称，后续可通过`get_model`接口进行查询。

```python
# 注意：此代码片段依赖于完整的 runtime 初始化和上下文配置，不能单独运行，请参考完整代码示例。
model1 = _get_model(1)
model2 = _get_model(2)
runtime.add_models([("model_1", model1), ("model_2", model2)])
print(f"model_1 存在: {runtime.get_model('model_1') is not None}")
print(f"model_2 存在: {runtime.get_model('model_2') is not None}")
```

输出：

```python
model_1 存在: True
model_2 存在: True
```

通过`remove_model`接口可删除已经添加的大模型实例，根据指定的实例名称进行删除。

```python
# 注意：此代码片段依赖于完整的 runtime 初始化和上下文配置，不能单独运行，请参考完整代码示例。
runtime.remove_model("model_1")
print(f"移除后 model_1: {runtime.get_model('model_1')}")
```

运行结果：

```python
移除后 model_1: None
```

完整代码：

```python
import asyncio

from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.component.end_comp import End
from openjiuwen.core.component.start_comp import Start
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.runtime.base import ComponentExecutable, Input, Output
from openjiuwen.core.runtime.runtime import Runtime
from openjiuwen.core.runtime.workflow import WorkflowRuntime
from openjiuwen.core.utils.llm.model_utils.model_factory import ModelFactory
from openjiuwen.core.workflow.base import Workflow


class CustomComponent(WorkflowComponent, ComponentExecutable):
    def __init__(self, workflow_id):
        super().__init__()
        self._workflow_id = workflow_id

    def _get_model(self, timeout):
        #需要修改替换api_base和api_key
        return ModelFactory().get_model(model_provider="openai", api_key="sk-****************************", api_base="your path model service", max_retrie=1, timeout=timeout)

    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        model = self._get_model(10)
        runtime.add_model("model", model)
        saved_model = runtime.get_model("model")
        print(f"保存模型: {type(saved_model).__name__}")

        model1 = self._get_model(1)
        model2 = self._get_model(2)
        runtime.add_models([("model_1", model1), ("model_2", model2)])
        print(f"model_1 存在: {runtime.get_model('model_1') is not None}")
        print(f"model_2 存在: {runtime.get_model('model_2') is not None}")

        runtime.remove_model("model_1")
        print(f"移除后 model_1: {runtime.get_model('model_1')}")

flow = Workflow()
flow.set_start_comp("start", Start())
flow.add_workflow_comp("custom", CustomComponent("custom"))
flow.set_end_comp("end", End())
flow.add_connection("start", "custom")
flow.add_connection("custom", "end")

if __name__ == "__main__":
    asyncio.run(flow.invoke(inputs={}, runtime=WorkflowRuntime()))
```

# 工具实例管理

`Runtime`提供了工具实例的添加、查询、删除、批量添加的能力。

通过`add_tool`接口可添加一个工具实例，添加的时候需要指定实例的唯一名称，后续可通过`get_tool`接口使用指定的名称查询已添加的实例。

```python
from openjiuwen.core.utils.tool.function.function import LocalFunction
from openjiuwen.core.utils.tool.param import Param
from openjiuwen.core.agent.agent import AgentRuntime

add_plugin = LocalFunction(
    name="add",
    description="加法",
    params=[
        Param(name="a", description="加数", type="number", required=True),
        Param(name="b", description="被加数", type="number", required=True),
    ],
    func=lambda a, b: a + b
)
runtime = AgentRuntime()
runtime.add_tool("add_plugin", add_plugin)

tool = runtime.get_tool("add_plugin")
print(tool.name)
```

输出结果：

```python
add
```

通过`add_tools`接口可批量添加工具实例，每个工具实例都需要指定唯一名称，后续可通过`get_tool`接口进行查询。

```python
from openjiuwen.core.utils.tool.function.function import LocalFunction
from openjiuwen.core.utils.tool.param import Param

add_plugin = LocalFunction(
    name="add",
    description="加法",
    params=[
        Param(name="a", description="加数", type="number", required=True),
        Param(name="b", description="被加数", type="number", required=True),
    ],
    func=lambda a, b: a + b
)

multiply_plugin = LocalFunction(
    name="multiply",
    description="乘法",
    params=[
        Param(name="a", description="乘数", type="number", required=True),
        Param(name="b", description="被乘数", type="number", required=True),
    ],
    func=lambda a, b: a * b
)


runtime.add_tools([("add_plugin", add_plugin), ("multiply_plugin", multiply_plugin)])
tool = runtime.get_tool("multiply_plugin")
print(tool.name)
```

输出结果：

```python
multiply
```

通过`remove_tool`接口可删除已经添加的工具实例，根据指定的实例名称进行删除。

```python
runtime.remove_tool("add_plugin")
print(runtime.get_tool("add_plugin"))
```

输出结果：

```python
None
```

完整代码：

```python
import asyncio

from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.component.end_comp import End
from openjiuwen.core.component.start_comp import Start
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.runtime.base import ComponentExecutable, Input, Output
from openjiuwen.core.runtime.runtime import Runtime
from openjiuwen.core.runtime.workflow import WorkflowRuntime
from openjiuwen.core.utils.tool.function.function import LocalFunction
from openjiuwen.core.utils.tool.param import Param
from openjiuwen.core.workflow.base import Workflow


class CustomComponent(WorkflowComponent, ComponentExecutable):
    def __init__(self, workflow_id):
        super().__init__()
        self._workflow_id = workflow_id

    def _create_workflow(self, workflow_config):
        workflow = Workflow(workflow_config)
        workflow.set_start_comp("start", Start())
        workflow.set_end_comp("end", End())
        workflow.add_connection("start", "end")
        return workflow

    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        add_plugin = LocalFunction(
            name="add",
            description="加法",
            params=[
                Param(name="a", description="加数", type="number", required=True),
                Param(name="b", description="被加数", type="number", required=True),
            ],
            func=lambda a, b: a + b
        )
        runtime.add_tool("add_plugin", add_plugin)

        tool = runtime.get_tool("add_plugin")
        print(tool.name)

        add_plugin = LocalFunction(
            name="add",
            description="加法",
            params=[
                Param(name="a", description="加数", type="number", required=True),
                Param(name="b", description="被加数", type="number", required=True),
            ],
            func=lambda a, b: a + b
        )

        multiply_plugin = LocalFunction(
            name="multiply",
            description="乘法",
            params=[
                Param(name="a", description="乘数", type="number", required=True),
                Param(name="b", description="被乘数", type="number", required=True),
            ],
            func=lambda a, b: a * b
        )

        runtime.add_tools([("add_plugin", add_plugin), ("multiply_plugin", multiply_plugin)])
        tool = runtime.get_tool("multiply_plugin")
        print(tool.name)

        runtime.remove_tool("add_plugin")
        print(runtime.get_tool("add_plugin"))


flow = Workflow()
flow.set_start_comp("start", Start())
flow.add_workflow_comp("custom", CustomComponent("custom"))
flow.set_end_comp("end", End())
flow.add_connection("start", "custom")
flow.add_connection("custom", "end")

if __name__ == "__main__":
    asyncio.run(flow.invoke(inputs={}, runtime=WorkflowRuntime()))
```
