# 状态管理

对话执行过程中通过`Runtime`统一访问状态数据，支持跨组件共享机制，有效降低属性传递的复杂度。所有状态数据集中存储于`Runtime`，可通过标准化接口进行读写操作，主要分为两类：

- **全局状态数据**：所有的组件都可读取和更新的数据，如会话历史数据，可通过调用`get_global_state`方法获取全局状态数据，`update_global_state`方法更新全局状态数据。
- **组件状态数据**：工作流组件自己的状态数据，如组件的执行次数、计算中间数据，可调用`get_state`方法获取组件状态数据，`update_state`方法更新组件状态数据。该数据只有当前组件可见，其他组件获取不到。

组件开发的过程中，根据需求选择将新增的状态数据记录到全局状态中或组件状态中，推荐根据状态的可见性来选择，若状态仅需在本组件可见，首选将状态数据记录到组件状态。

## 全局状态数据

全局状态是所有组件共享的数据空间，适用于记录执行轨迹等场景。

以在工作流中更新状态数据为例，增加全局状态信息`debug_messages`，用于记录工作流中执行过程中的运行信息，工作流的任何组件都可通过`get_global_state`方法获取。

创建自定义组件`NodeDemo`，用于获取和更新当前的状态数据`debug_messages`：

```python
from openjiuwen.core.runtime.base import ComponentExecutable
from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.runtime.runtime import Runtime
from openjiuwen.core.graph.executable import Input, Output


class NodeDemo(ComponentExecutable, WorkflowComponent):
    def __init__(self, node_id):
        super().__init__()
        self.node_id = node_id

    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        # 获取当前debug_messages的状态数据
        debug_messages = runtime.get_global_state("debug_messages")
        print(f"{self.node_id}: debug_messages={debug_messages}")

        # 更新状态数据
        new_debug_messages = []
        if debug_messages:
            new_debug_messages.extend(debug_messages)
        new_debug_messages.append({self.node_id: {"inputs": inputs}})
        runtime.update_global_state({"debug_messages": new_debug_messages})

        # 打印更新完的状态数据
        print(f"{self.node_id}: after update debug_messages={runtime.get_global_state('debug_messages')}")
        return {"output": inputs}
```

创建简单工作流，并执行：

```python
import asyncio
from openjiuwen.core.runtime.workflow import WorkflowRuntime
from openjiuwen.core.workflow.base import  Workflow

flow = Workflow()
flow.set_start_comp("start", NodeDemo("start"), inputs_schema={'a': '${user_inputs.a}'})
flow.add_workflow_comp("node", NodeDemo("node"), inputs_schema={'a': '${start.output.a}'})
flow.set_end_comp("end", NodeDemo("end"), inputs_schema={'a': '${node.output.a}'})
flow.add_connection("start", "node")
flow.add_connection("node", "end")

# 执行工作流
runtime = WorkflowRuntime()
output = asyncio.run(flow.invoke({"user_inputs": {"a": 1}}, runtime))
print(output)
```

运行结果如下，可看出工作流的状态数据更新的生效时间是在本组件执行完成：

```python
start: debug_messages=None
start: after update debug_messages=None
node: debug_messages=[{'start': {'inputs': {'a': 1}}}]
node: after update debug_messages=[{'start': {'inputs': {'a': 1}}}]
end: debug_messages=[{'start': {'inputs': {'a': 1}}}, {'node': {'inputs': {'a': 1}}}]
end: after update debug_messages=[{'start': {'inputs': {'a': 1}}}, {'node': {'inputs': {'a': 1}}}]
result={'output': {'a': 1}} state=<WorkflowExecutionState.COMPLETED: 'COMPLETED'>
```

## 组件状态数据

组件状态数据是自定义组件的私有数据空间，用于存储组件专属信息（如执行次数、中间结果等）。

以两个自定义组件为例，创建自定义组件`AddTenComponent`，该组件通过`call_times`记录了当前组件的执行次数。并创建第二个自定义组件`CustomEnd`去尝试读取`call_times`。

`AddTenComponent`是一个在工作流中反复执行的自定义组件，用于对全局数值进行累加（每次 +10），同时维护自身私有的执行次数状态`call_times`。该组件通过​**组件状态数据**​（`update_state`）记录自身执行次数，确保状态仅在本组件内部可见；同时通过​**全局状态数据**​（`update_global_state`）更新共享的累加值`num`，供其他组件读取：

```python
from openjiuwen.core.runtime.base import ComponentExecutable
from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.runtime.runtime import Runtime
from openjiuwen.core.graph.executable import Input, Output

class AddTenComponent(ComponentExecutable, WorkflowComponent):
    def __init__(self, node_id):
        super().__init__()
        self._node_id = node_id

    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output: 
        # 获取当前组件私有状态：执行次数
        call_times = runtime.get_state("call_times") or 0
        # 获取全局共享状态：累加数值
        num = runtime.get_global_state("num") or 0
        
        # 更新组件私有状态：执行次数 +1
        call_times += 1
        runtime.update_state({"call_times": call_times})
        
        # 执行运算：num += 10
        num += 10
        runtime.update_global_state({"num": num})
        
        # 打印调试信息
        print(f"[{self._node_id}] 执行第 {call_times} 次，num = {num - 10} → {num}")
        
        return inputs
```

`CustomEnd`是一个用于验证**组件状态隔离性**的终端组件。它尝试读取`AddTenComponent`维护的私有状态`call_times`，并获取全局状态`num`，以演示**组件状态仅限本组件可见**的特性。该组件不修改任何状态，仅用于观察和验证：

```python
from openjiuwen.core.runtime.base import ComponentExecutable
from openjiuwen.core.component.base import WorkflowComponent
from openjiuwen.core.context_engine.base import Context
from openjiuwen.core.runtime.runtime import Runtime
from openjiuwen.core.graph.executable import Input, Output

class CustomEnd(ComponentExecutable, WorkflowComponent):
    def __init__(self, node_id):
        super().__init__()
        self._node_id = node_id

    async def invoke(self, inputs: Input, runtime: Runtime, context: Context) -> Output:
        # 尝试读取其他组件的私有状态（预期不可见）
        call_times = runtime.get_state("call_times")
        print(f'->[CustomEnd] 获取 call_times = {call_times}')  # 输出: None
        
        # 读取全局共享状态（预期可见）
        num = runtime.get_global_state("num")
        print(f'->[CustomEnd] 获取 num = {num}')
        
        return inputs
```

创建工作流，并添加分支组件：

```python
from openjiuwen.core.workflow.base import  Workflow
from openjiuwen.core.component.branch_comp import BranchComponent
from openjiuwen.core.component.start_comp import Start

# 创建工作流
flow = Workflow()
flow.set_start_comp("start", Start())
flow.set_end_comp("end", CustomEnd("end"))
flow.add_workflow_comp("a", AddTenComponent("a"))

# 增加分支组件，触发AddTenComponent的多次调用

sw = BranchComponent()
sw.add_branch("${num} <= 30", ["a"], "1")
sw.add_branch("${num} > 30", ["end"], "2")

flow.add_workflow_comp("sw", sw)
flow.add_connection("start", "a")
flow.add_connection("a", "sw")
```

调用工作流：

```python
import asyncio
from openjiuwen.core.runtime.workflow import WorkflowRuntime
# 调用工作流
asyncio.run(flow.invoke({}, WorkflowRuntime()))
```

执行结果如下，可发现，`AddTenComponent`每次执行都可获取到最新的状态`call_times`，此外，由于`call_times`是`AddTenComponent`组件私有的状态，因此`CustomEnd`获取不到该状态：

```python
[a] 执行第 1 次，num = 0 → 10
[a] 执行第 2 次，num = 10 → 20
[a] 执行第 3 次，num = 20 → 30
[a] 执行第 4 次，num = 30 → 40
->[CustomEnd] 获取 call_times = None
->[CustomEnd] 获取 num = 40
```
