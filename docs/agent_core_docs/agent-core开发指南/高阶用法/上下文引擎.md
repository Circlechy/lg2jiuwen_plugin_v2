上下文引擎（Context Engine）是openJiuwen框架的核心组件，主要负责模型输入上下文信息的管理。提供了对上下文信息（包括长短期记忆、工具、知识等）的记录、获取、筛选等标准化管理能力，帮助开发者在构建Agent时更高效地处理上下文内容。

上下文引擎的开发流程分为以下两步：

- 获取上下文：支持获取智能体范围的上下文实例AgentContext和智能体特定工作流范围的上下文实例WorkflowContext，并通过session_id实现上下文隔离。
- 使用上下文：支持单条或批量添加对话消息，并可按数量、角色、标签等条件进行消息查询，同时支持为消息添加自定义标签以进行元数据管理。

# 获取上下文

用户可根据自己需求获取智能体或智能体的工作流的上下文实例。

## 获取Agent上下文

用户在创建Agent过程中，会自动创建上下文引擎，因此可先创建Agent，以获取对应的上下文实例。

### 创建Agent

首先使用openJiuwen提供的`ReActAgent`类的构造函数实例化对象。该Agent提供特定日期的天气查询的功能。示例代码如下：

```python
import os
os.environ['LLM_SSL_VERIFY'] = 'false'

from datetime import datetime
from openjiuwen.agent.common.schema import PluginSchema
from openjiuwen.agent.react_agent import create_react_agent_config, ReActAgent
from openjiuwen.core.component.common.configs.model_config import ModelConfig
from openjiuwen.core.utils.llm.base import BaseModelInfo
from openjiuwen.core.utils.tool.param import Param
from openjiuwen.core.utils.tool.service_api.restful_api import RestfulApi

API_BASE = os.getenv("API_BASE", "your api base")
API_KEY = os.getenv("API_KEY", "your api key")
MODEL_NAME = os.getenv("MODEL_NAME", "")
MODEL_PROVIDER = os.getenv("MODEL_PROVIDER", "")

def build_current_date():
    current_datetime = datetime.now()
    return current_datetime.strftime("%Y-%m-%d")

def _create_model():
    return ModelConfig(model_provider=MODEL_PROVIDER,
                       model_info=BaseModelInfo(
                           model=MODEL_NAME,
                           api_base=API_BASE,
                           api_key=API_KEY,
                           temperature=0.7,
                           top_p=0.9,
                           timeout=30
                       ))

def _create_tool():
    weather_plugin = RestfulApi(
        name="WeatherReporter",
        description="天气查询插件",
        params=[
            Param(name="location", description="天气查询的地点，必须为英文", type="string", required=True),
            Param(name="date", description="天气查询的时间，格式为YYYY-MM-DD", type="string", required=True),
        ],
        path="your weather search api url",
        headers={},
        method="GET",
        response=[],
    )
    return weather_plugin

def _create_prompt_template():
    system_prompt = "你是一个AI助手，在适当的时候调用合适的工具，帮助我完成任务！今天的日期为：{}\n注意：1. 如果用户请求中未指定具体时间，则默认为今天。"
    return [
        dict(role="system", content=system_prompt.format(build_current_date()))
    ]

agent_id="react_agent_123"
model_config = _create_model()
prompt_template = _create_prompt_template()

react_agent_config = create_react_agent_config(
    agent_id=agent_id,
    agent_version="0.0.1",
    description="AI助手",
    model=model_config,
    prompt_template=prompt_template
)

react_agent: ReActAgent = ReActAgent(react_agent_config)
react_agent.add_tools([_create_tool()])
```

### 获取Agent上下文实例

通过`react_agent.context_engine`可以获取到Agent的上下文，接着`get_agent_context`方法根据会话id（即：`session_id`）获取AgentContext类型的上下文实例，用于整个智能体范围的上下文管理。

```python
# 通过session_id获取agent中上下文实例
agent_context = react_agent.context_engine.get_agent_context(session_id= "your_session_id")
```

## 获取Agent的workflow上下文

用户创建Agent时往往需要绑定一个或多个工作流，为了实现细分的上下文管理，可以通过`get_workflow_context`获取指定workflow的上下文引擎。

### 创建绑定workflow的Agent

首先使用openJiuwen提供的`WorkflowAgent`创建工作流智能体，同时绑定特定的工作流。以提供天气查询功能的工作流智能体为例，创建和绑定过程的示例代码如下：

```python
from openjiuwen.agent.common.schema import WorkflowSchema
from openjiuwen.agent.workflow_agent.workflow_agent import WorkflowAgent
from openjiuwen.agent.config.workflow_config import WorkflowAgentConfig
from openjiuwen.core.workflow.base import Workflow
from openjiuwen.core.workflow.workflow_config import WorkflowConfig, WorkflowMetadata

agent_id = "weather_agent_test"
workflow_id = "your_workflow_id"
workflow_name = "weather"
workflow_version = "1.0"

workflow_config = WorkflowConfig(
    metadata=WorkflowMetadata(
        name=workflow_name,
        id=workflow_id,
        version=workflow_version,
    )
)
flow = Workflow(workflow_config=workflow_config)

schema = WorkflowSchema(
    id=workflow_id,
    name=workflow_name,
    description="天气查询工作流",
    version=workflow_version,
    inputs={"query": {"type": "string"}}
)

config = WorkflowAgentConfig(
    id=agent_id,
    version="0.1.0",
    description="测试用天气 agent",
    workflows=[schema],
)

workflow_agent = WorkflowAgent(config)
workflow_agent.bind_workflows([flow])
```

### 获取Agent的workflow上下文实例

通过`workflow_agent.context_engine`可以获取到Agent的上下文，接着使用`get_workflow_context`方法根据工作流id和会话id，即`workflow_id`和`session_id`，获取WorkflowContext类型的工作流上下文实例，用于Agent的工作流范围的上下文管理。

```python
# 通过workflow_id和session_id获取工作流中上下文实例
workflow_context = workflow_agent.context_engine.get_workflow_context(workflow_id = "your_workflow_id", session_id = "your_session_id")
```

# 使用上下文

获取AgentContext或WorkflowContext类型的上下文之后，可以对上下文进行灵活使用。主要功能包括：
 - 添加消息：单条或批量添加对话消息，同时支持为消息添加自定义标签以进行元数据管理。
 - 查询消息：查询历史消息列表，并支持按角色、标签等条件进行过滤、筛选。

## 添加信息

支持单条或批量添加对话消息，同时消息添加可支持自定义标签，便于后续元数据管理和查询。

### 添加单条信息

使用`add_message`方法可以添加单条消息，支持添加`SystemMessage`、`ToolMessage`、 `HumanMessage`和 `AIMessage`类型的消息。并支持通过tags标记消息的元数据，便于后续筛选和分类。消息会自动分配顺序ID，以保证对话的时序性。

```python
from openjiuwen.core.utils.llm.messages import HumanMessage, AIMessage

# 添加用户消息
user_message = HumanMessage(content="你好，请帮我查询天气")
agent_context.add_message(user_message, tags={"type": "user_input", "time": "2024-01-01"})

# 添加AI回复消息
ai_message = AIMessage(content="今天天气晴朗，温度25度。")
agent_context.add_message(ai_message, tags={"type": "ai_response", "model": "gpt-4"})
```

### 添加多条信息

使用`batch_add_messages`方法可以批量添加多条消息，并为整批消息设置相同的标签，提高效率，适用于初始化对话历史或批量导入场景。

```python
from openjiuwen.core.utils.llm.messages import HumanMessage, AIMessage

# 准备消息列表
messages = [
    HumanMessage(content="你好，请问你能帮我什么？"),
    AIMessage(content="我可以帮您解答问题、处理任务等。"),
    HumanMessage(content="今天天气怎么样？"),
    AIMessage(content="今天天气晴朗，温度25度。")
]

# 批量添加消息
agent_context.batch_add_messages(messages, tags={"source": "user_input", "batch_id": "001"})
```

## 查询信息

支持按数量、角色、标签等条件进行消息查询。

### get_messages查询信息

`get_messages`方法支持通过数量和标签查询历史消息，并返回消息列表。返回的消息按照时间先后顺序排列，即最新的消息在最后。

首先构造一批测试消息，以下查询信息方法均以此为基础：

```python
from openjiuwen.core.utils.llm.messages import HumanMessage, AIMessage, SystemMessage

agent_context.add_message(HumanMessage(content="第一条用户消息"), tags={"type": "greeting"})
agent_context.add_message(AIMessage(content="第一条AI回复"))
agent_context.add_message(HumanMessage(content="今天天气怎么样？"), tags={"type": "weather_query"})
agent_context.add_message(AIMessage(content="今天天气晴朗。"))
agent_context.add_message(SystemMessage(content="系统提示：对话结束"))
```

#### 根据数量查询

根据数量查询消息，返回最近的`num`条消息。如果`num`超过最大消息长度则返回全部消息。

```python
# 样例：获取最近3条消息
recent_messages = agent_context.get_messages(3)
print("最近3条消息：")
for i, msg in enumerate(recent_messages):
    print(f"  {i+1}. {type(msg).__name__}: {msg.content}")
```

输出结果如下：

```text
最近3条消息：
  1. HumanMessage: 今天天气怎么样？
  2. AIMessage: 今天天气晴朗。
  3. SystemMessage: 系统提示：对话结束
```

#### 根据标签查询

根据标签查询消息，返回与标签精确匹配的最新的`num`条消息。

```python
# 样例：获取带特定标签的最近消息
tagged_messages = agent_context.get_messages(10, tags={"type": "weather_query"})
print("带标签'weather_query'的消息：")
for i, msg in enumerate(tagged_messages):
    print(f"  {i+1}. {type(msg).__name__}: {msg.content}")
```

输出结果如下：

```text
带标签'weather_query'的消息：
  1. HumanMessage: 今天天气怎么样？
```

### get_latest_message查询信息

`get_latest_message`方法可以获取最新的一条消息。

默认获取最新的一条消息：

```python
# 样例1：获取最新的一条消息（不限角色）
latest_message = agent_context.get_latest_message()
print(f"最新消息: {type(latest_message).__name__}: {latest_message.content}")
```

输出结果如下：

```text
最新消息: SystemMessage: 系统提示：对话结束
```

也支持传入`role`参数来过滤特定角色的最新消息，支持role的类型如下：`user`、`assistant`、`system`和`tool`。

```python
# 样例2：获取最新的用户消息
latest_user_message = agent_context.get_latest_message(role="user")
print(f"最新用户消息: {type(latest_user_message).__name__}: {latest_user_message.content}")
```

输出结果如下：

```text
最新用户消息: HumanMessage: 今天天气怎么样？
```

如果找不到符合条件的消息，返回 `None`。

```python
# 样例3：获取不存在的角色消息
nonexistent_message = agent_context.get_latest_message(role="tool")
print(f"不存在的角色消息: {nonexistent_message}")
```

输出结果如下：

```text
不存在的角色消息: None
```

# 完整的使用上下文引擎代码示例

以下是一个完整的使用上下文引擎的代码示例：

```python
import os
import asyncio
from datetime import datetime
from openjiuwen.agent.react_agent import create_react_agent_config, ReActAgent
from openjiuwen.core.component.common.configs.model_config import ModelConfig
from openjiuwen.core.utils.llm.base import BaseModelInfo
from openjiuwen.core.utils.tool.param import Param
from openjiuwen.core.utils.tool.service_api.restful_api import RestfulApi
from openjiuwen.core.utils.llm.messages import HumanMessage, AIMessage, SystemMessage

os.environ['LLM_SSL_VERIFY'] = 'false'
API_BASE = os.getenv("API_BASE", "your api base")
API_KEY = os.getenv("API_KEY", "your api key")
MODEL_NAME = os.getenv("MODEL_NAME", "")
MODEL_PROVIDER = os.getenv("MODEL_PROVIDER", "")

def build_current_date():
    current_datetime = datetime.now()
    return current_datetime.strftime("%Y-%m-%d")


def _create_model():
    return ModelConfig(model_provider=MODEL_PROVIDER,
                       model_info=BaseModelInfo(
                           model=MODEL_NAME,
                           api_base=API_BASE,
                           api_key=API_KEY,
                           temperature=0.7,
                           top_p=0.9,
                           timeout=30
                       ))


def _create_tool():
    weather_plugin = RestfulApi(
        name="WeatherReporter",
        description="天气查询插件",
        params=[
            Param(name="location", description="天气查询的地点，必须为英文", type="string", required=True),
            Param(name="date", description="天气查询的时间，格式为YYYY-MM-DD", type="string", required=True),
        ],
        path="your weather search api url",
        headers={},
        method="GET",
        response=[],
    )
    return weather_plugin


def _create_prompt_template():
    system_prompt = "你是一个AI助手，在适当的时候调用合适的工具，帮助我完成任务！今天的日期为：{}\n注意：1. 如果用户请求中未指定具体时间，则默认为今天。"
    return [
        dict(role="system", content=system_prompt.format(build_current_date()))
    ]


agent_id = "react_agent_123"
model_config = _create_model()
prompt_template = _create_prompt_template()

react_agent_config = create_react_agent_config(
    agent_id=agent_id,
    agent_version="0.0.1",
    description="AI助手",
    model=model_config,
    prompt_template=prompt_template
)

# 创建react_agent过程中，自动创建上下文引擎
react_agent = ReActAgent(react_agent_config)
react_agent.add_tools([_create_tool()])


async def run():
    # 生成会话id
    session_id = "your_session_id"

    # 调用agent
    result = await react_agent.invoke({"query": "查询杭州的天气", "conversation_id": session_id})

    # 通过session_id获取agent中上下文实例
    agent_context = react_agent.context_engine.get_agent_context(session_id=session_id)

    # 1. agent自动产生的消息
    recent_msgs = agent_context.get_messages(10)
    print("1. agent自动产生的消息:")
    for i, msg in enumerate(recent_msgs):
        print(f"     {i + 1}. {type(msg).__name__}: {msg.content}")

    # 2. 单条添加消息
    print("2. 手动单条添加消息")
    user_msg1 = HumanMessage(content="你好，我想查询天气")
    agent_context.add_message(user_msg1, tags={"intent": "weather_query", "step": "init"})
    print(f"   添加用户消息: '{user_msg1.content}'")

    ai_msg1 = AIMessage(content="您好！我可以帮您查询天气，请告诉我您想查询哪个城市？")
    agent_context.add_message(ai_msg1, tags={"type": "response", "step": "ask_city"})
    print(f"   添加AI回复: '{ai_msg1.content}'\n")

    # 3. 批量添加消息
    print("3. 批量添加消息")
    conversation_messages = [
        HumanMessage(content="我想查询北京的天气"),
        AIMessage(content="北京今天晴转多云，气温15-25度，空气质量良"),
        HumanMessage(content="谢谢你的帮助"),
        AIMessage(content="不客气，有任何问题随时问我！")
    ]
    agent_context.batch_add_messages(
        conversation_messages,
        tags={"city": "beijing", "conversation": "complete"}
    )
    print(f"   批量添加 {len(conversation_messages)} 条消息\n")

    # 4. 添加系统消息
    print("4. 添加系统消息")
    system_msg = SystemMessage(content="系统：对话已保存")
    agent_context.add_message(system_msg, tags={"type": "system_notification"})
    print(f"   添加系统消息: '{system_msg.content}'\n")

    # 5. 查询功能演示
    print("5. 消息查询功能演示")

    # 5.1 查询最近消息
    recent_msgs = agent_context.get_messages(10)
    print("   最近10条消息:")
    for i, msg in enumerate(recent_msgs):
        print(f"     {i + 1}. {type(msg).__name__}: {msg.content}")

    # 5.2 按标签查询
    tagged_msgs = agent_context.get_messages(10, tags={"city": "beijing"})
    print(f"\n   带标签'city=beijing'的消息 ({len(tagged_msgs)}条):")
    for i, msg in enumerate(tagged_msgs):
        print(f"     {i + 1}. {type(msg).__name__}: {msg.content}")

    # 5.3 查询最新消息
    print("\n   最新消息查询:")
    latest_msg = agent_context.get_latest_message()
    print(f"     不限角色: {type(latest_msg).__name__}: {latest_msg.content}")

    latest_user = agent_context.get_latest_message(role="user")
    print(f"     用户角色: {type(latest_user).__name__}: {latest_user.content}")

    latest_ai = agent_context.get_latest_message(role="assistant")
    print(f"     AI角色: {type(latest_ai).__name__}: {latest_ai.content}")

    # 6. 统计信息
    print("\n6. 上下文统计")
    all_msgs = agent_context.get_messages(-1)
    user_count = len([msg for msg in all_msgs if hasattr(msg, 'role') and msg.role == 'user'])
    ai_count = len([msg for msg in all_msgs if hasattr(msg, 'role') and msg.role == 'assistant'])
    system_count = len([msg for msg in all_msgs if hasattr(msg, 'role') and msg.role == 'system'])

    print(f"   总消息数: {len(all_msgs)}")
    print(f"   用户消息: {user_count}")
    print(f"   AI回复: {ai_count}")
    print(f"   系统消息: {system_count}")


if __name__ == "__main__":
    asyncio.run(run())
```

输出结果如下：

```text
1. agent自动产生的消息:
     1. HumanMessage: 查询杭州的天气
     2. AIMessage: 
     3. ToolMessage: {"errCode": 182000, "errMessage": "plugin request unknown error", "data": ""}
     4. AIMessage: 查询杭州的天气时出现了未知错误，可能是服务暂时不可用。您可以稍后再试，或者告诉我是否需要帮助解决其他问题。
2. 手动单条添加消息
   添加用户消息: '你好，我想查询天气'
   添加AI回复: '您好！我可以帮您查询天气，请告诉我您想查询哪个城市？'

3. 批量添加消息
   批量添加 4 条消息

4. 添加系统消息
   添加系统消息: '系统：对话已保存'

5. 消息查询功能演示
   最近10条消息:
     1. AIMessage: 
     2. ToolMessage: {"errCode": 182000, "errMessage": "plugin request unknown error", "data": ""}
     3. AIMessage: 查询杭州的天气时出现了未知错误，可能是服务暂时不可用。您可以稍后再试，或者告诉我是否需要帮助解决其他问题。
     4. HumanMessage: 你好，我想查询天气
     5. AIMessage: 您好！我可以帮您查询天气，请告诉我您想查询哪个城市？
     6. HumanMessage: 我想查询北京的天气
     7. AIMessage: 北京今天晴转多云，气温15-25度，空气质量良
     8. HumanMessage: 谢谢你的帮助
     9. AIMessage: 不客气，有任何问题随时问我！
     10. SystemMessage: 系统：对话已保存

   带标签'city=beijing'的消息 (4条):
     1. HumanMessage: 我想查询北京的天气
     2. AIMessage: 北京今天晴转多云，气温15-25度，空气质量良
     3. HumanMessage: 谢谢你的帮助
     4. AIMessage: 不客气，有任何问题随时问我！

   最新消息查询:
     不限角色: SystemMessage: 系统：对话已保存
     用户角色: HumanMessage: 谢谢你的帮助
     AI角色: AIMessage: 不客气，有任何问题随时问我！

6. 上下文统计
   总消息数: 11
   用户消息: 4
   AI回复: 5
   系统消息: 1
```


