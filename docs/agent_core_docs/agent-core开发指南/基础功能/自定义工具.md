openJiuwen支持以下三种方式将开发者自定义工具转换为可被LLM识别和调用的工具：

- 工具化本地函数：提供`@tool`装饰器，可将本地Python函数注册为可被LLM调用的Tool类，从而实现类似Function Calling的能力。
- 封装Restful接口：提供`RestfulApi`类，可便捷定义和管理符合Restful风格的API接口，包括接口名称、描述、参数、路径、请求头、请求方法和响应信息等，从而实现统一、规范的接口管理与调用。
- 封装MCP接口：提供`MCPTool`类，可便捷封装MCP服务，从而实现MCP服务的统一接口管理与调用。

# 工具化本地函数

openJiuwen提供了`@tool`装饰器，用于封装本地Python函数生成`Tool`类，从而可被LLM识别与调用。

## @tool装饰器封装本地函数

开发者自定义的本地Python函数，可使用`@tool`装饰器进行封装。`@tool`装饰器需开发者配置函数名字、函数描述和参数等信息，用于准确描述本地Python函数，建议参考本地函数的定义进行配置。

```python
from openjiuwen.core.utils.tool.param import Param
from openjiuwen.core.utils.tool.tool import tool

# 开发者实现add函数，使用tool装饰器进行封装
@tool(name="add",
    description="本地加法插件",
    params=[
        Param(name="a", description="第一个参数", type="int", required=True),
        Param(name="b", description="第二个参数", type="int", required=True),
    ])
def add(a: int, b: int) -> int:
    return a + b
```

## 调用工具

通过`@tool`装饰器生成的`Tool`类可被LLM识别与调用。根据`@tool`装饰器中的参数定义，准备相应的工具输入，然后调用Tool类的`invoke`方法，即可触发本地函数的执行逻辑。

```python
# 生成Tool类，可被LLM识别与调用
tool_info = add.get_tool_info()
print(f"调用成功，返回结果: {tool_info}")

inputs = {
    "a": 5,
    "b": 1
}
result = add.invoke(inputs=inputs)
print(f"调用成功，返回结果: {result}")
```

样例输出：

```text
调用成功，返回结果: type='function' name='add' description='本地加法插件' parameters=Parameters(type='object', properties={'a': {'description': '第一个参数', 'type': 'string'}, 'b': {'description': '第二个参数', 'type': 'string'}}, required=['a', 'b'])
调用成功，返回结果: 6
```

# 封装Restful接口

openJiuwen提供了`RestfulApi`类，用于封装Restful Api服务，生成的`RestfulApi`类可被LLM识别与调用。

## RestfulApi类封装Restful Api服务

开发者自定义实现并部署Restful Api服务后，可使用openJiuwen提供的`RestfulApi`类进行封装。`RestfulApi`类需配置接口名称、描述、参数、路径、请求头、请求方法和响应等信息，用于描述restful api服务。建议参考RestfulApi服务的接口进行配置。

```python
import asyncio

from openjiuwen.core.utils.tool.service_api.restful_api import RestfulApi
from openjiuwen.core.utils.tool.param import Param

# 开发者自定义实现部署weather restful api服务，在创建天气查询插件的RestfulApi实例
weather_plugin = RestfulApi(
    name="WeatherReporter",
    description="天气查询插件",
    params=[
        Param(name="location", description="天气查询的地点，必须为英文", type="string", required=True),
        Param(name="date", description="天气查询的时间，格式为YYYY-MM-DD", type="string", required=True),
    ],
    path="your weather search api url", # 天气查询服务部署地址
    headers={},
    method="GET",
    response=[],
)
```

## 调用工具

`RestfulApi`类可被LLM识别与调用，参考`RestfulApi`类的参数定义，准备工具输入，调用`RestfulApi`类的`invoke`方法会远程运行Restful Api服务。

```python
# RestfulApi实例，可被LLM识别与调用
tool_info = weather_plugin.get_tool_info()
print(f"调用成功，返回结果: {tool_info}")

inputs = {
    "location": "beijing",
    "date": "2023-10-01"
}
loop = asyncio.get_event_loop()
result = loop.run_until_complete(weather_plugin.ainvoke(inputs=inputs))
print(f"调用成功，返回结果: {result}")
```

样例输出：

```text
调用成功，返回结果: type='function' name='WeatherReporter' description='天气查询插件' parameters=Parameters(type='object', properties={'location': {'description': '天气查询的地点，必须为英文', 'type': 'string'}, 'date': {'description': '天气查询的时间，格式为YYYY-MM-DD', 'type': 'string'}}, required=['location', 'date'])
调用成功，返回结果: beijing 2023-10-01的天气晴朗
```

# 封装MCP接口

openJiuwen提供`MCPTool`类，用于封装MCP服务，生成的`MCPTool`类可被LLM识别与调用。


## MCPTool类封装MCP服务

开发者自定义实现并部署MCP服务后，可使用openJiuwen提供的`MCPTool`类进行封装。`MCPTool`类需配置MCP Client、输入Schema、服务名称等信息用于描述MCP服务。当前支持SSE、stdio、playwright等多种Transport方式。

```python
import asyncio
from openjiuwen.core.utils.tool.mcp.base import MCPTool, SseClient

# 开发者自定义实现部署weather MCP服务，再创建天气查询插件的MCPTool实例。
mcp_client = SseClient(server_path="your weather mcp url", name="MockSseClient")
await mcp_client.connect(timeout=10)
tool_info_list = await mcp_client.list_tools()
for tool_info in tool_info_list:
    print("调用成功，返回结果:", tool_info.model_dump_json())
mcp_tool = MCPTool(mcp_client=mcp_client, tool_info=tool_info_list[0])
```
样例输出：

```text
调用成功，返回结果: {"type":"function","name":"query_weather","description":"","parameters":null,"input_schema":{"properties":{"location":{"title":"Location","type":"string"}},"required":["location"],"title":"query_weatherArguments","type":"object"},"server_name":""}
```

## 调用工具

`MCPTool`类可被LLM识别与调用，参考`MCPTool`类的参数定义，准备工具输入，调用`MCPTool`类的`ainvoke`方法会远程运行MCP 服务。

```python
# MCPTool实例，可被LLM识别与调用
tool_info = mcp_tool.get_tool_info()
print(f"调用成功，返回结果: {tool_info}")

inputs = {
    "location": "beijing",
}
result = await mcp_tool.ainvoke(inputs=inputs)
print(f"调用成功，返回结果: {result}")
await mcp_client.disconnect()
```

样例输出：

```text
调用成功，返回结果: type='function' name='query_weather' description='' parameters=None input_schema={'properties': {'location': {'title': 'Location', 'type': 'string'}}, 'required': ['location'], 'title': 'query_weatherArguments', 'type': 'object'} server_name=''
调用成功，返回结果: {'result': '{\n  "location": "beijing",\n  "temperature": "22℃",\n  "condition": "晴"\n}'}
```
